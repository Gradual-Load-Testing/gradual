{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Gradual","text":"<p>A comprehensive Python stress testing framework for applications and systems.</p>"},{"location":"#what-is-gradual","title":"What is Gradual?","text":"<p>Gradual is a powerful, extensible stress testing framework designed to help developers and DevOps engineers validate the performance and reliability of their applications under various load conditions. Built with Python, it provides a flexible and intuitive way to create, execute, and analyze stress tests.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 High Performance: Built on gevent for efficient concurrency</li> <li>\ud83d\udd0c Protocol Support: HTTP, WebSocket, and custom protocol support</li> <li>\ud83d\udcca Real-time Monitoring: Live dashboard with Bokeh visualizations</li> <li>\ud83d\udcc8 Comprehensive Metrics: Detailed performance analytics and reporting</li> <li>\ud83d\udd10 Authentication: Support for Kerberos, NTLM, OAuth, and more</li> <li>\ud83c\udf10 Distributed Testing: Scale tests across multiple machines</li> <li>\ud83d\udcdd YAML Configuration: Simple, declarative test configuration</li> <li>\ud83c\udfaf CLI Interface: Easy-to-use command-line tools</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Install Gradual\npip install -e \".[dev,bokeh,websockets]\"\n\n# Run a stress test\nstress-run --test_config examples/api_test.yaml --request_config examples/requests.yaml\n\n# Start the monitoring dashboard\nstress-dashboard --mode bokeh\n</code></pre>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TB\n    A[Test Configuration] --&gt; B[Configuration Parser]\n    B --&gt; C[Orchestrator]\n    C --&gt; D[Phase Runner]\n    D --&gt; E[Scenario Runner]\n    E --&gt; F[Request Execution]\n\n    G[Reporting] --&gt; H[Metrics Collection]\n    G --&gt; I[Results Output]\n\n    J[Configuration Files] --&gt; B\n    K[YAML Parser] --&gt; B\n    L[Validation] --&gt; B</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Quick Start Guide: Get up and running in minutes</li> <li>User Guide: Learn how to use Gradual for stress testing</li> <li>Configuration Reference: Complete configuration options and examples</li> <li>Development Guide: Contribute to the framework development</li> <li>API Reference: Complete API documentation</li> <li>Examples: Real-world usage examples</li> <li>Contributing: How to contribute to the project</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcd6 Documentation: This site contains comprehensive guides</li> <li>\ud83d\udc1b Issues: Report bugs on GitHub Issues</li> <li>\ud83d\udcac Discussions: Join the conversation on GitHub Discussions</li> <li>\ud83d\udce7 Contact: Reach out to the maintainers</li> </ul>"},{"location":"#license","title":"License","text":"<p>Gradual is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"configuration_reference/","title":"Configuration Reference","text":"<p>This document provides a comprehensive reference for all configuration options available in Gradual. It's designed to be your go-to resource for understanding, configuring, and troubleshooting Gradual stress tests.</p> <p>\ud83d\udca1 This is the dedicated Configuration Reference guide. For a quick overview, see the User Guide.</p>"},{"location":"configuration_reference/#overview","title":"Overview","text":"<p>Gradual uses a two-file configuration system:</p> <ol> <li>Test Configuration (<code>test_config.yaml</code>) - Defines the overall test structure, phases, and scenarios</li> <li>Request Configuration (<code>request_config.yaml</code>) - Defines individual HTTP and WebSocket requests and their parameters</li> </ol>"},{"location":"configuration_reference/#command-line-usage","title":"Command-Line Usage","text":"<p>The <code>stress-run</code> command is the main entry point for running stress tests. It accepts the following arguments:</p> <pre><code>stress-run --test_config &lt;test_config_file&gt; [--request_config &lt;request_config_file&gt;]\n</code></pre>"},{"location":"configuration_reference/#arguments","title":"Arguments","text":"Argument Type Required Description <code>test_config</code> path Yes Path to the main test configuration file (YAML) <code>request_config</code> path No Path to the request configuration file (YAML). If not provided, requests must be defined inline in the test configuration."},{"location":"configuration_reference/#examples","title":"Examples","text":"<pre><code># Run with both configuration files\nstress-run --test_config test_config.yaml --request_config request_config.yaml\n\n# Run with only test configuration (requests defined inline)\nstress-run --test_config test_config.yaml\n\n# Run with relative paths\nstress-run --test_config ./configs/test.yaml --request_config ./configs/requests.yaml\n</code></pre>"},{"location":"configuration_reference/#dashboard-command","title":"Dashboard Command","text":"<p>The <code>stress-dashboard</code> command provides real-time monitoring:</p> <pre><code># Start Bokeh dashboard (interactive charts)\nstress-dashboard --mode bokeh --port 8080\n\n# Start WebSocket dashboard (lightweight)\nstress-dashboard --mode websocket --port 8081\n\n# Start with custom host\nstress-dashboard --mode bokeh --host 0.0.0.0 --port 8080\n</code></pre> <p>\u26a0\ufe0f Important: The CLI does not support command-line overrides for configuration values. All test parameters must be defined in the YAML configuration files.</p>"},{"location":"configuration_reference/#cli-implementation-details","title":"CLI Implementation Details","text":"<p>The current CLI implementation is intentionally simple and focused:</p> <ul> <li>No command-line overrides: All test parameters (concurrency, duration, ramp-up, etc.) must be defined in YAML files</li> <li>No output format options: Results are displayed in the console by default</li> <li>No debug flags: Logging level is controlled by the configuration files</li> <li>No report generation: Use the dashboard for real-time monitoring and analysis</li> </ul> <p>This design ensures that:</p> <ul> <li>Tests are reproducible and version-controlled</li> <li>Configuration is explicit and documented</li> <li>Test behavior is consistent across different environments</li> <li>Users focus on proper test design rather than command-line tweaking</li> </ul>"},{"location":"configuration_reference/#cli-source-code","title":"CLI Source Code","text":"<p>The CLI is implemented in <code>scripts/run_stress_test.py</code> and provides a minimal interface:</p> <pre><code>parser = ArgumentParser()\nparser.add_argument(\n    \"--test_config\",\n    type=pathlib.Path,\n    required=True,\n    help=\"Path to the test configuration file\",\n)\nparser.add_argument(\n    \"--request_config\", \n    type=pathlib.Path, \n    help=\"Path to the request configuration file\"\n)\n</code></pre> <p>This simplicity allows for:</p> <ul> <li>Easy integration with CI/CD pipelines</li> <li>Consistent behavior across different environments</li> <li>Clear separation of concerns between CLI and configuration</li> <li>Focus on test design rather than command-line complexity</li> </ul>"},{"location":"configuration_reference/#test-configuration-file","title":"Test Configuration File","text":"<p>The test configuration file is the main configuration file that defines how your stress test will be executed.</p>"},{"location":"configuration_reference/#top-level-structure","title":"Top-Level Structure","text":"<pre><code>runs:\n  name: \"Test Run Name\"\n  wait_between_phases: 10\n  phases:\n    \"phase_name\":\n      # Phase configuration\n</code></pre>"},{"location":"configuration_reference/#run-configuration","title":"Run Configuration","text":"Field Type Required Description <code>name</code> string Yes Name of the test run <code>wait_between_phases</code> integer No Wait time between phases in seconds (default: 0)"},{"location":"configuration_reference/#phase-configuration","title":"Phase Configuration","text":"<p>Each phase represents a distinct period of testing with specific load characteristics.</p> <pre><code>\"phase_name\":\n  scenarios:\n    \"scenario_name\":\n      # Scenario configuration\n  run_time: 300\n</code></pre> Field Type Required Description <code>scenarios</code> object Yes Dictionary of scenarios to run in this phase <code>run_time</code> integer Yes Duration of the phase in seconds"},{"location":"configuration_reference/#scenario-configuration","title":"Scenario Configuration","text":"<p>Scenarios define specific test patterns with their own concurrency and ramp-up settings.</p> <pre><code>\"scenario_name\":\n  requests:\n    - \"request1\"\n    - \"request2\"\n  min_concurrency: 1\n  max_concurrency: 10\n  ramp_up_multiply: [1, 2, 4, 8]\n  ramp_up_wait: [5, 5, 5, 5]\n  iterate_through_requests: true\n  run_once: false\n</code></pre> Field Type Required Description <code>requests</code> list[string] or \"FROM_REQUEST_YAML_FILE\" Yes List of request names (must match request config) or \"FROM_REQUEST_YAML_FILE\" to use all requests from request config <code>min_concurrency</code> integer Yes Starting number of concurrent requests <code>max_concurrency</code> integer Yes Maximum number of concurrent requests <code>ramp_up_multiply</code> integer or list[integer] No* Multiplicative Ramp-up: Multipliers for gradually increasing concurrency. <code>ramp_up_add</code> integer or list[integer] No* Additive Ramp-up: Additive values for gradually increasing concurrency. <code>ramp_up_wait</code> integer or list[integer] No Wait time between ramp-up steps in seconds (default: [0.1]). <code>iterate_through_requests</code> boolean No Whether to cycle through requests sequentially (default: false) <code>run_once</code> boolean No Whether to run the scenario only once (default: false) <p>*Note: Either <code>ramp_up_multiply</code> or <code>ramp_up_add</code> must be specified, but not both.</p>"},{"location":"configuration_reference/#request-configuration-file","title":"Request Configuration File","text":"<p>The request configuration file defines individual HTTP and WebSocket requests that can be referenced by scenarios. The system supports both traditional HTTP requests and WebSocket connections for real-time communication testing. Additionally, a plugin feature is in development that will allow users to run custom I/O requests based on their specific requirements.</p>"},{"location":"configuration_reference/#structure","title":"Structure","text":"<pre><code>requests:\n  \"request_name\":\n    url: \"http://example.com/api/endpoint\"\n    method: \"GET\"\n    expected_response_time: 1.0\n    auth: null\n    params:\n      key: \"value\"\n</code></pre>"},{"location":"configuration_reference/#request-fields","title":"Request Fields","text":"Field Type Required Description <code>url</code> string Yes Full URL for the request (HTTP) or WebSocket endpoint (ws:// or wss://) <code>method</code> string Yes HTTP method (GET, POST, PUT, DELETE, etc.) or \"WEBSOCKET\" for WebSocket connections <code>expected_response_time</code> number Yes Expected response time in seconds <code>auth</code> object/null No Authentication configuration (null for none) <code>params</code> object No Request parameters (for GET) or body data (for POST/PUT) <code>websocket_config</code> object No WebSocket-specific configuration (only for WebSocket requests) <p>Note: For WebSocket requests, set <code>method: \"WEBSOCKET\"</code> and optionally include <code>websocket_config</code> for custom WebSocket behavior. The plugin feature will provide additional request types and custom I/O capabilities.</p>"},{"location":"configuration_reference/#websocket-configuration","title":"WebSocket Configuration","text":"<p>For WebSocket requests, you can specify additional configuration options:</p> <pre><code>requests:\n  \"websocket_test\":\n    url: \"ws://localhost:8080/ws\"\n    method: \"WEBSOCKET\"\n    expected_response_time: 2.0\n    websocket_config:\n      message_interval: 1.0  # Send message every 1 second\n      max_messages: 100      # Maximum messages to send\n      message_template: \"Test message {counter}\"\n      close_after: 60        # Close connection after 60 seconds\n</code></pre>"},{"location":"configuration_reference/#plugin-feature-work-in-progress","title":"Plugin Feature (Work in Progress)","text":"<p>The plugin system is currently under development and will enable users to: - Create custom request types beyond HTTP and WebSocket - Implement custom I/O operations (file I/O, database operations, etc.) - Extend the system with domain-specific testing capabilities - Integrate with external systems and APIs</p> <p>This feature will provide a flexible framework for testing various types of systems and protocols.</p>"},{"location":"configuration_reference/#ramp-up-strategies","title":"Ramp-up Strategies","text":"<p>Gradual supports two types of ramp-up strategies to gradually increase load on your system.</p>"},{"location":"configuration_reference/#multiplicative-ramp-up","title":"Multiplicative Ramp-up","text":"<p>Use <code>ramp_up_multiply</code> to multiply the current request count by specified factors:</p> <pre><code>ramp_up_multiply: [1, 2, 4, 8, 16]\nramp_up_wait: [5, 5, 5, 5, 5]\n</code></pre> <p>Execution Flow:</p> <pre><code>flowchart LR\n    A[Start: 1 request] --&gt; B[Wait 5s] --&gt; C[Multiply by 2&lt;br/&gt;Now: 2 requests] --&gt; D[Wait 5s] --&gt; E[Multiply by 4&lt;br/&gt;Now: 8 requests] --&gt; F[Wait 5s] --&gt; G[Multiply by 8&lt;br/&gt;Now: 64 requests] --&gt; H[Wait 5s] --&gt; I[Multiply by 16&lt;br/&gt;Now: 1024 requests]\n\n    style A fill:#e1f5fe,font-size:50px\n    style I fill:#ffebee,font-size:50px\n    style B fill:#f3e5f5,font-size:50px\n    style D fill:#f3e5f5,font-size:50px\n    style F fill:#f3e5f5,font-size:50px\n    style H fill:#f3e5f5,font-size:50px\n    style C fill:#f9f9f9,font-size:50px\n    style E fill:#f9f9f9,font-size:50px\n    style G fill:#f9f9f9,font-size:50px</code></pre>"},{"location":"configuration_reference/#additive-ramp-up","title":"Additive Ramp-up","text":"<p>Use <code>ramp_up_add</code> to add specified numbers of requests:</p> <pre><code>ramp_up_add: [1, 2, 3, 4, 5]\nramp_up_wait: [2, 2, 2, 2, 2]\n</code></pre> <p>Execution Flow:</p> <pre><code>flowchart LR\n    A[Start: 1 request] --&gt; B[Wait 2s] --&gt; C[Add 1&lt;br/&gt;Now: 2 requests] --&gt; D[Wait 2s] --&gt; E[Add 2&lt;br/&gt;Now: 4 requests] --&gt; F[Wait 2s] --&gt; G[Add 3&lt;br/&gt;Now: 7 requests] --&gt; H[Wait 2s] --&gt; I[Add 4&lt;br/&gt;Now: 11 requests] --&gt; J[Wait 2s] --&gt; K[Add 5&lt;br/&gt;Now: 16 requests]\n\n    style A fill:#e1f5fe,font-size:50px\n    style K fill:#ffebee,font-size:50px\n    style B fill:#f3e5f5,font-size:50px\n    style D fill:#f3e5f5,font-size:50px\n    style F fill:#f3e5f5,font-size:50px\n    style H fill:#f3e5f5,font-size:50px\n    style J fill:#f3e5f5,font-size:50px\n    style C fill:#f9f9f9,font-size:50px\n    style E fill:#f9f9f9,font-size:50px\n    style G fill:#f9f9f9,font-size:50px\n    style I fill:#f9f9f9,font-size:50px</code></pre>"},{"location":"configuration_reference/#ramp-up-wait-times","title":"Ramp-up Wait Times","text":"<p>The <code>ramp_up_wait</code> field can be:</p> <ul> <li>Single value: Applied to all ramp-up steps</li> <li>List of values: Applied to each ramp-up step individually</li> </ul> <pre><code># Single value - wait 5 seconds between all steps\nramp_up_wait: 5\n\n# List of values - wait different times between steps\nramp_up_wait: [5, 10, 15, 20]\n</code></pre>"},{"location":"configuration_reference/#configuration-examples","title":"Configuration Examples","text":""},{"location":"configuration_reference/#simple-load-test","title":"Simple Load Test","text":"<pre><code># test_config.yaml\nruns:\n  name: \"Simple API Test\"\n  wait_between_phases: 0\n  phases:\n    \"main_test\":\n      scenarios:\n        \"api_scenario\":\n          requests:\n            - \"health_check\"\n            - \"get_data\"\n          min_concurrency: 1\n          max_concurrency: 50\n          ramp_up_multiply: [1, 2, 5, 10, 25, 50]\n          ramp_up_wait: [10, 10, 10, 10, 10, 10]\n          iterate_through_requests: true\n      run_time: 300\n\n# Mixed HTTP and WebSocket test\nruns:\n  name: \"Mixed Protocol Test\"\n  wait_between_phases: 5\n  phases:\n    \"http_phase\":\n      scenarios:\n        \"http_scenario\":\n          requests:\n            - \"api_endpoint\"\n            - \"data_fetch\"\n          min_concurrency: 10\n          max_concurrency: 100\n          ramp_up_multiply: [1, 2, 4, 8, 16, 32, 64, 100]\n          ramp_up_wait: 5\n      run_time: 120\n    \"websocket_phase\":\n      scenarios:\n        \"websocket_scenario\":\n          requests:\n            - \"websocket_connection\"\n            - \"realtime_data\"\n          min_concurrency: 5\n          max_concurrency: 50\n          ramp_up_add: [5, 10, 15, 20]\n          ramp_up_wait: 10\n      run_time: 180\n</code></pre> <pre><code># request_config.yaml\nrequests:\n  \"health_check\":\n    url: \"http://localhost:8000/health\"\n    method: \"GET\"\n    expected_response_time: 0.5\n    auth: null\n  \"get_data\":\n    url: \"http://localhost:8000/api/data\"\n    method: \"GET\"\n    expected_response_time: 1.0\n    auth: null\n</code></pre>"},{"location":"configuration_reference/#multi-phase-stress-test","title":"Multi-Phase Stress Test","text":"<pre><code># test_config.yaml\nruns:\n  name: \"Stress Test with Recovery\"\n  wait_between_phases: 30\n  phases:\n    \"warm_up\":\n      scenarios:\n        \"light_load\":\n          requests:\n            - \"health_check\"\n          min_concurrency: 1\n          max_concurrency: 10\n          ramp_up_multiply: [1, 2, 5, 10]\n          ramp_up_wait: [5, 5, 5, 5]\n          iterate_through_requests: true\n      run_time: 120\n    \"peak_load\":\n      scenarios:\n        \"heavy_load\":\n          requests:\n            - \"complex_operation\"\n            - \"data_processing\"\n          min_concurrency: 10\n          max_concurrency: 200\n          ramp_up_multiply: [10, 25, 50, 100, 200]\n          ramp_up_wait: [15, 15, 15, 15, 15]\n          iterate_through_requests: true\n      run_time: 600\n    \"recovery\":\n      scenarios:\n        \"recovery_test\":\n          requests:\n            - \"health_check\"\n          min_concurrency: 200\n          max_concurrency: 1\n          ramp_up_add: [-50, -50, -50, -49]\n          ramp_up_wait: [10, 10, 10, 10]\n          iterate_through_requests: true\n      run_time: 180\n</code></pre> <pre><code># request_config.yaml\nrequests:\n  \"health_check\":\n    url: \"http://localhost:8000/health\"\n    method: \"GET\"\n    expected_response_time: 0.5\n    auth: null\n  \"complex_operation\":\n    url: \"http://localhost:8000/api/complex\"\n    method: \"POST\"\n    expected_response_time: 5.0\n    auth: null\n    params:\n      operation: \"heavy_computation\"\n      data_size: 1000\n  \"data_processing\":\n    url: \"http://localhost:8000/api/process\"\n    method: \"POST\"\n    expected_response_time: 3.0\n    auth: null\n    params:\n      batch_size: 100\n      priority: \"high\"\n</code></pre>"},{"location":"configuration_reference/#authentication-example","title":"Authentication Example","text":"<pre><code># request_config.yaml\nrequests:\n  \"authenticated_endpoint\":\n    url: \"http://localhost:8000/api/protected\"\n    method: \"GET\"\n    expected_response_time: 1.0\n    auth:\n      type: \"bearer\"\n      token: \"your_auth_token\"\n    params: {}\n</code></pre>"},{"location":"configuration_reference/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"configuration_reference/#dynamic-request-loading","title":"Dynamic Request Loading","text":"<p>For advanced use cases, you can reference requests from external files:</p> <pre><code># In test_config.yaml\nscenarios:\n  \"dynamic_scenario\":\n    requests: \"FROM_REQUEST_YAML_FILE\"\n    request_file: path/to/external_requests.yaml\n    # ... other scenario configuration\n</code></pre>"},{"location":"configuration_reference/#single-vs-list-values","title":"Single vs. List Values","text":"<p>Many configuration fields accept both single values and lists. When a single value is provided, it's automatically converted to a list:</p> <pre><code># These are equivalent:\nramp_up_multiply: 5\nramp_up_multiply: [5]\n\n# These are equivalent:\nramp_up_wait: 10\nramp_up_wait: [10]\n</code></pre>"},{"location":"configuration_reference/#validation-rules","title":"Validation Rules","text":""},{"location":"configuration_reference/#required-fields","title":"Required Fields","text":"<ul> <li>Test Config: <code>runs.name</code>, <code>runs.phases</code>, <code>phases.scenarios</code>, <code>scenarios.requests</code>, <code>scenarios.min_concurrency</code>, <code>scenarios.max_concurrency</code>, <code>phases.run_time</code></li> <li>Request Config: <code>requests.url</code>, <code>requests.method</code>, <code>requests.expected_response_time</code></li> </ul>"},{"location":"configuration_reference/#value-constraints","title":"Value Constraints","text":"<ul> <li>Concurrency: Must be positive integers</li> <li>Timing: Must be positive numbers</li> <li>Ramp-up: Must specify either <code>ramp_up_multiply</code> or <code>ramp_up_add</code>, but not both</li> <li>Request References: Request names in scenarios must exist in the request configuration</li> </ul>"},{"location":"configuration_reference/#best-practices","title":"Best Practices","text":"<ol> <li>Naming: Use descriptive names for phases, scenarios, and requests</li> <li>Structure: Keep test structure and request definitions separate</li> <li>Reusability: Define requests once and reuse across multiple scenarios</li> <li>Ramp-up: Start with conservative ramp-up values and adjust based on system performance</li> <li>Phases: Use phases to test different load patterns and allow system recovery</li> <li>Documentation: Add comments to complex configurations for clarity</li> </ol>"},{"location":"configuration_reference/#configuration-first-approach","title":"Configuration-First Approach","text":"<p>Since the CLI doesn't support command-line overrides, adopt a configuration-first approach:</p> <ul> <li>Version Control: Keep all test configurations in version control for reproducibility</li> <li>Environment-Specific Configs: Create separate configuration files for different environments (dev, staging, prod)</li> <li>Configuration Templates: Use base templates and extend them for specific test scenarios</li> <li>Parameterization: Use YAML anchors and aliases to avoid duplication</li> <li>Validation: Always validate your YAML syntax before running tests</li> </ul> <p>Example of using YAML anchors for reusability:</p> <pre><code># test_config.yaml\nruns:\n  name: \"Parameterized Test\"\n  wait_between_phases: 10\n  phases:\n    \"light_load\": &amp;light_load\n      scenarios:\n        \"light_scenario\":\n          requests: [\"health_check\", \"simple_api\"]\n          min_concurrency: 1\n          max_concurrency: 10\n          ramp_up_multiply: [1, 2, 5, 10]\n          ramp_up_wait: [5, 5, 5, 5]\n          iterate_through_requests: true\n      run_time: 120\n\n    \"medium_load\":\n      &lt;&lt;: *light_load  # Inherit from light_load\n      scenarios:\n        \"medium_scenario\":\n          &lt;&lt;: *light_load.scenarios.light_scenario  # Inherit scenario config\n          max_concurrency: 50\n          ramp_up_multiply: [1, 5, 15, 30, 50]\n          ramp_up_wait: [10, 10, 10, 10, 10]\n      run_time: 300\n</code></pre>"},{"location":"configuration_reference/#troubleshooting-configuration-issues","title":"Troubleshooting Configuration Issues","text":""},{"location":"configuration_reference/#common-errors","title":"Common Errors","text":"<ol> <li>Missing Request Definition: Ensure all request names in scenarios exist in the request configuration</li> <li>Invalid Ramp-up: Check that either <code>ramp_up_multiply</code> or <code>ramp_up_add</code> is specified, but not both</li> <li>Type Mismatches: Verify that numeric fields contain valid numbers</li> <li>File Paths: Ensure configuration files are in the correct locations</li> </ol>"},{"location":"configuration_reference/#debug-tips","title":"Debug Tips","text":"<ul> <li>Use the <code>--debug</code> flag when running tests to see detailed configuration parsing</li> <li>Check YAML syntax with a YAML validator</li> <li>Verify file permissions and paths</li> <li>Test with minimal configurations first, then add complexity gradually</li> </ul>"},{"location":"contributing/","title":"Contributing to Gradual","text":"<p>Thank you for your interest in contributing to the Gradual stress testing framework! This guide will help you get started with contributing to the project.</p>"},{"location":"contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Code of Conduct</li> <li>Getting Started</li> <li>Development Setup</li> <li>Contribution Workflow</li> <li>Code Standards</li> <li>Testing Guidelines</li> <li>Documentation</li> <li>Release Process</li> <li>Community</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>This project adheres to a Code of Conduct. By participating, you are expected to uphold this code. Please report unacceptable behavior to the project maintainers.</p>"},{"location":"contributing/#our-standards","title":"Our Standards","text":"<ul> <li>Be respectful and inclusive</li> <li>Be collaborative and open to feedback</li> <li>Be constructive in criticism and suggestions</li> <li>Be professional in all interactions</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>Git</li> <li>Basic understanding of Python development</li> <li>Familiarity with stress testing concepts (helpful but not required)</li> </ul>"},{"location":"contributing/#areas-to-contribute","title":"Areas to Contribute","text":"<p>We welcome contributions in many areas:</p> <ul> <li>Core Framework: Protocol handlers, assertions, data providers</li> <li>Documentation: User guides, API reference, examples</li> <li>Testing: Unit tests, integration tests, performance benchmarks</li> <li>Examples: Test configurations, use cases, tutorials</li> <li>Bug Fixes: Issue resolution, performance improvements</li> <li>Features: New protocols, reporting capabilities, integrations</li> </ul>"},{"location":"contributing/#good-first-issues","title":"Good First Issues","text":"<p>Look for issues labeled with: - <code>good first issue</code> - Beginner-friendly - <code>help wanted</code> - General help needed - <code>documentation</code> - Documentation improvements - <code>bug</code> - Bug fixes</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":""},{"location":"contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code># Fork the repository on GitHub\n# Then clone your fork\ngit clone https://github.com/YOUR_USERNAME/gradual.git\ncd gradual\n\n# Add the upstream remote\ngit remote add upstream https://github.com/Gradual-Load-Testing/gradual.git\n</code></pre>"},{"location":"contributing/#2-environment-setup","title":"2. Environment Setup","text":"<pre><code># Create virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install development dependencies\npip install -e \".[dev]\"\n\n# Install pre-commit hooks\npre-commit install\n</code></pre>"},{"location":"contributing/#3-verify-setup","title":"3. Verify Setup","text":"<pre><code># Run tests to ensure everything works\nmake test\n\n# Run linting\nmake lint\n\n# Run type checking\nmake typecheck\n</code></pre>"},{"location":"contributing/#contribution-workflow","title":"Contribution Workflow","text":""},{"location":"contributing/#1-create-a-feature-branch","title":"1. Create a Feature Branch","text":"<pre><code># Update your main branch\ngit checkout main\ngit pull upstream main\n\n# Create a new feature branch\ngit checkout -b feature/your-feature-name\n</code></pre>"},{"location":"contributing/#2-make-your-changes","title":"2. Make Your Changes","text":"<ul> <li>Write your code following the Code Standards</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> <li>Ensure all tests pass</li> </ul>"},{"location":"contributing/#3-commit-your-changes","title":"3. Commit Your Changes","text":"<pre><code># Stage your changes\ngit add .\n\n# Commit with a descriptive message\ngit commit -m \"feat: add custom protocol handler support\n\n- Implement BaseProtocolHandler interface\n- Add TCP protocol support\n- Include comprehensive tests\n- Update documentation\"\n</code></pre>"},{"location":"contributing/#4-push-and-create-pull-request","title":"4. Push and Create Pull Request","text":"<pre><code># Push your branch\ngit push origin feature/your-feature-name\n\n# Create a Pull Request on GitHub\n# Fill out the PR template with details about your changes\n</code></pre>"},{"location":"contributing/#5-code-review","title":"5. Code Review","text":"<ul> <li>Address any feedback from reviewers</li> <li>Make requested changes</li> <li>Ensure CI checks pass</li> <li>Maintainers will merge when ready</li> </ul>"},{"location":"contributing/#code-standards","title":"Code Standards","text":""},{"location":"contributing/#python-style-guide","title":"Python Style Guide","text":"<p>We follow PEP 8 with some modifications:</p> <ul> <li>Line Length: 88 characters (Black default)</li> <li>Import Sorting: isort with Black profile</li> <li>Type Hints: Required for public APIs</li> <li>Docstrings: Google-style docstrings</li> </ul>"},{"location":"contributing/#code-formatting","title":"Code Formatting","text":"<pre><code># Format code with Black\nmake format\n# or\nblack src/ tests/\n\n# Sort imports\nmake sort-imports\n# or\nisort src/ tests/\n</code></pre>"},{"location":"contributing/#linting-and-type-checking","title":"Linting and Type Checking","text":"<pre><code># Run all quality checks\nmake quality\n\n# Run specific checks\nmake lint      # flake8\nmake typecheck # mypy\nmake test      # pytest\n</code></pre>"},{"location":"contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>The project uses pre-commit hooks to ensure code quality:</p> <pre><code># Install hooks\npre-commit install\n\n# Run manually\npre-commit run --all-files\n</code></pre>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"contributing/#test-structure","title":"Test Structure","text":"<pre><code>import pytest\nfrom gradual.base import BaseProtocolHandler\n\nclass TestCustomProtocolHandler:\n    \"\"\"Test the custom protocol handler implementation.\"\"\"\n\n    def test_initialization(self):\n        \"\"\"Test handler initialization with config.\"\"\"\n        config = {\"timeout\": 30}\n        handler = CustomProtocolHandler(config)\n        assert handler.config == config\n\n    def test_execute_request_success(self):\n        \"\"\"Test successful request execution.\"\"\"\n        handler = CustomProtocolHandler({})\n        result = handler.execute_request({\"message\": \"test\"})\n        assert result[\"status\"] == \"success\"\n\n    def test_execute_request_failure(self):\n        \"\"\"Test request execution failure.\"\"\"\n        handler = CustomProtocolHandler({})\n        result = handler.execute_request({})\n        assert result[\"status\"] == \"error\"\n</code></pre>"},{"location":"contributing/#test-requirements","title":"Test Requirements","text":"<ul> <li>Coverage: Aim for &gt;90% code coverage</li> <li>Naming: Use descriptive test names and docstrings</li> <li>Isolation: Tests should be independent and repeatable</li> <li>Mocking: Mock external dependencies appropriately</li> <li>Fixtures: Use pytest fixtures for common setup</li> </ul>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nmake test\n\n# Run specific test files\npytest tests/test_protocols.py\n\n# Run with coverage\npytest --cov=src/gradual --cov-report=html\n\n# Run performance tests\npytest tests/benchmarks/ -m \"not slow\"\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#code-documentation","title":"Code Documentation","text":"<ul> <li>Docstrings: Use Google-style docstrings for all public methods</li> <li>Type Hints: Include type hints for function parameters and return values</li> <li>Examples: Provide usage examples in docstrings</li> <li>Exceptions: Document all exceptions that may be raised</li> </ul> <p>Example:</p> <pre><code>def execute_test_scenario(self, scenario: dict, user_data: dict) -&gt; dict:\n    \"\"\"Execute a test scenario with user data.\n\n    Args:\n        scenario: Scenario configuration dictionary containing\n                 steps, assertions, and metadata.\n        user_data: User-specific data for the scenario execution.\n\n    Returns:\n        Dictionary containing execution results including\n        status, response time, and any extracted data.\n\n    Raises:\n        ScenarioExecutionError: If scenario execution fails due to\n                               configuration or runtime errors.\n        ValidationError: If response validation fails for any\n                        assertion in the scenario.\n\n    Example:\n        &gt;&gt;&gt; scenario = {\"steps\": [{\"request\": {\"method\": \"GET\"}}]}\n        &gt;&gt;&gt; user_data = {\"user_id\": \"123\"}\n        &gt;&gt;&gt; result = runner.execute_test_scenario(scenario, user_data)\n        &gt;&gt;&gt; print(result[\"status\"])\n        'success'\n    \"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#api-documentation","title":"API Documentation","text":"<ul> <li>Completeness: Document all public APIs</li> <li>Examples: Include usage examples</li> <li>Breaking Changes: Document any breaking changes</li> <li>Migration Guides: Provide migration paths for major changes</li> </ul>"},{"location":"contributing/#user-documentation","title":"User Documentation","text":"<ul> <li>Clarity: Write clear, concise instructions</li> <li>Examples: Provide real-world examples</li> <li>Troubleshooting: Include common issues and solutions</li> <li>Screenshots: Add visual aids where helpful</li> </ul>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":""},{"location":"contributing/#pr-title-and-description","title":"PR Title and Description","text":"<pre><code>## Description\nBrief description of what this PR accomplishes.\n\n## Type of Change\n- [ ] Bug fix (non-breaking change which fixes an issue)\n- [ ] New feature (non-breaking change which adds functionality)\n- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)\n- [ ] Documentation update\n\n## Testing\n- [ ] Unit tests pass\n- [ ] Integration tests pass\n- [ ] Manual testing completed\n- [ ] Documentation updated\n\n## Checklist\n- [ ] Code follows the style guidelines\n- [ ] Self-review of code completed\n- [ ] Code is commented, particularly in hard-to-understand areas\n- [ ] Corresponding changes to documentation made\n- [ ] Changes generate no new warnings\n- [ ] Tests added that prove fix is effective or feature works\n- [ ] New and existing unit tests pass locally\n- [ ] AI assistance (e.g., Cursor, ChatGPT, Claude) was used in making these changes (please specify tools in the PR description)\n</code></pre>"},{"location":"contributing/#review-process","title":"Review Process","text":"<ol> <li>Automated Checks: Ensure CI checks pass</li> <li>Code Review: Address reviewer feedback</li> <li>Testing: Verify functionality works as expected</li> <li>Documentation: Update relevant documentation</li> <li>Merge: Maintainers will merge when ready</li> </ol>"},{"location":"contributing/#release-process","title":"Release Process","text":""},{"location":"contributing/#version-management","title":"Version Management","text":"<p>We use semantic versioning (MAJOR.MINOR.PATCH):</p> <ul> <li>MAJOR: Breaking changes</li> <li>MINOR: New features (backward compatible)</li> <li>PATCH: Bug fixes (backward compatible)</li> </ul>"},{"location":"contributing/#release-checklist","title":"Release Checklist","text":"<ul> <li> All tests pass</li> <li> Documentation is up to date</li> <li> Changelog is updated</li> <li> Version is bumped in <code>pyproject.toml</code></li> <li> Release notes are written</li> <li> GitHub release is created</li> <li> PyPI package is published (maintainers only)</li> </ul>"},{"location":"contributing/#creating-a-release","title":"Creating a Release","text":"<pre><code># Update version\n# Edit pyproject.toml\n\n# Build package\nmake build\n\n# Test installation\npip install dist/*.whl\n\n# Create git tag\ngit tag v1.0.0\ngit push origin v1.0.0\n\n# Publish to PyPI (maintainers only)\nmake publish\n</code></pre>"},{"location":"contributing/#community","title":"Community","text":""},{"location":"contributing/#communication-channels","title":"Communication Channels","text":"<ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>GitHub Discussions: Questions and general discussion</li> <li>GitHub Pull Requests: Code contributions</li> <li>Email: Direct contact with maintainers</li> </ul>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Start with the user guide and API reference</li> <li>Examples: Check the examples directory for usage patterns</li> <li>Issues: Search existing issues for similar problems</li> <li>Discussions: Ask questions in GitHub Discussions</li> </ul>"},{"location":"contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in several ways:</p> <ul> <li>Contributors List: GitHub automatically tracks contributors</li> <li>Release Notes: Contributors are credited in release notes</li> <li>Documentation: Contributors are listed in documentation</li> <li>Community: Active contributors are invited to join the maintainer team</li> </ul>"},{"location":"contributing/#code-of-conduct-enforcement","title":"Code of Conduct Enforcement","text":""},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you experience or witness unacceptable behavior:</p> <ol> <li>Document: Record the incident with details</li> <li>Report: Contact project maintainers privately</li> <li>Escalate: If needed, escalate to GitHub support</li> </ol>"},{"location":"contributing/#enforcement-actions","title":"Enforcement Actions","text":"<p>Maintainers may take actions including:</p> <ul> <li>Warning: Private or public warning</li> <li>Temporary Ban: Temporary restriction from participation</li> <li>Permanent Ban: Permanent removal from the project</li> </ul>"},{"location":"contributing/#next-steps","title":"Next Steps","text":"<ol> <li>Read the Documentation: Familiarize yourself with the project</li> <li>Join Discussions: Participate in GitHub Discussions</li> <li>Pick an Issue: Start with a good first issue</li> <li>Make a Contribution: Submit your first pull request</li> <li>Stay Engaged: Continue contributing and helping others</li> </ol> <p>Thank you for contributing to Gradual! Your contributions help make stress testing more accessible and powerful for everyone.</p>"},{"location":"dev_guide/","title":"Development Guide","text":"<p>This guide helps developers contribute to the Gradual stress testing framework.</p>"},{"location":"dev_guide/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"dev_guide/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>Git</li> <li>Make (optional, for using Makefile commands)</li> </ul>"},{"location":"dev_guide/#initial-setup","title":"Initial Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/Gradual-Load-Testing/gradual.git\ncd gradual\n\n# Create virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install development dependencies\npip install -e \".[dev]\"\n\n# Install pre-commit hooks\npre-commit install\n</code></pre>"},{"location":"dev_guide/#development-dependencies","title":"Development Dependencies","text":"<p>The project uses several development tools:</p> <ul> <li>pytest: Testing framework</li> <li>black: Code formatting</li> <li>isort: Import sorting</li> <li>flake8: Linting</li> <li>mypy: Type checking</li> <li>pre-commit: Git hooks</li> </ul>"},{"location":"dev_guide/#project-structure","title":"Project Structure","text":"<pre><code>gradual/\n\u251c\u2500\u2500 src/gradual/           # Main source code\n\u2502   \u251c\u2500\u2500 __init__.py        # Package initialization\n\u2502   \u251c\u2500\u2500 base/              # Base classes and interfaces\n\u2502   \u2502   \u2514\u2500\u2500 orchestrator.py # Main test orchestration\n\u2502   \u251c\u2500\u2500 configs/           # Configuration management\n\u2502   \u2502   \u251c\u2500\u2500 parser.py      # Configuration parser\n\u2502   \u2502   \u251c\u2500\u2500 phase.py       # Phase configuration\n\u2502   \u2502   \u251c\u2500\u2500 request.py     # Request configuration\n\u2502   \u2502   \u251c\u2500\u2500 scenario.py    # Scenario configuration\n\u2502   \u2502   \u2514\u2500\u2500 validate.py    # Configuration validation\n\u2502   \u251c\u2500\u2500 constants/         # Constants and enums\n\u2502   \u251c\u2500\u2500 exceptions.py      # Custom exceptions\n\u2502   \u251c\u2500\u2500 reporting/         # Reporting and metrics\n\u2502   \u2514\u2500\u2500 runners/           # Test runners\n\u2502       \u251c\u2500\u2500 runner.py      # Main test runner\n\u2502       \u251c\u2500\u2500 phase.py       # Phase execution\n\u2502       \u251c\u2500\u2500 scenario.py    # Scenario execution\n\u2502       \u251c\u2500\u2500 session.py     # Session management\n\u2502       \u2514\u2500\u2500 iterators.py   # Concurrency iterators\n\u251c\u2500\u2500 tests/                 # Test suite\n\u251c\u2500\u2500 docs/                  # Documentation\n\u251c\u2500\u2500 examples/              # Example configurations\n\u251c\u2500\u2500 benchmarks/            # Performance benchmarks\n\u2514\u2500\u2500 scripts/               # Utility scripts\n</code></pre>"},{"location":"dev_guide/#code-style-and-standards","title":"Code Style and Standards","text":""},{"location":"dev_guide/#python-style-guide","title":"Python Style Guide","text":"<p>We follow PEP 8 with some modifications:</p> <ul> <li>Line Length: 88 characters (Black default)</li> <li>Import Sorting: isort with Black profile</li> <li>Type Hints: Required for public APIs</li> </ul>"},{"location":"dev_guide/#code-formatting","title":"Code Formatting","text":"<pre><code># Format code with Black\nmake format\n# or\nblack src/ tests/\n\n# Sort imports\nmake sort-imports\n# or\nisort src/ tests/\n</code></pre>"},{"location":"dev_guide/#linting-and-type-checking","title":"Linting and Type Checking","text":"<pre><code># Run all quality checks\nmake quality\n\n# Run specific checks\nmake lint      # flake8\nmake typecheck # mypy\nmake test      # pytest\n</code></pre>"},{"location":"dev_guide/#testing","title":"Testing","text":""},{"location":"dev_guide/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nmake test\n\n# Run specific test files\npytest tests/test_runners.py\n\n# Run with coverage\npytest --cov=src/gradual --cov-report=html\n\n# Run performance tests\npytest tests/benchmarks/ -m \"not slow\"\n</code></pre>"},{"location":"dev_guide/#writing-tests","title":"Writing Tests","text":"<p>Follow these guidelines:</p> <ol> <li>Test Structure: Use descriptive test names and docstrings</li> <li>Fixtures: Use pytest fixtures for common setup</li> <li>Mocking: Mock external dependencies</li> <li>Coverage: Aim for &gt;90% code coverage</li> </ol> <p>Example test:</p> <pre><code>import pytest\nfrom gradual.base.orchestrator import Orchestrator\n\nclass TestOrchestrator:\n    \"\"\"Test the orchestrator class.\"\"\"\n\n    def test_initialization(self):\n        \"\"\"Test orchestrator initialization with config paths.\"\"\"\n        test_config = \"test_config.yaml\"\n        request_config = \"request_config.yaml\"\n        orchestrator = Orchestrator(test_config, request_config)\n        assert orchestrator.test_config_file_path == test_config\n        assert orchestrator.request_configs_path == request_config\n\n    def test_parser_initialization(self):\n        \"\"\"Test that parser is properly initialized.\"\"\"\n        orchestrator = Orchestrator(\"test.yaml\", \"request.yaml\")\n        assert orchestrator.parser is not None\n</code></pre>"},{"location":"dev_guide/#architecture-overview","title":"Architecture Overview","text":""},{"location":"dev_guide/#core-components","title":"Core Components","text":"<pre><code>graph TB\n    A[Test Configuration] --&gt; B[Configuration Parser]\n    B --&gt; C[Orchestrator]\n    C --&gt; D[Phase Runner]\n    D --&gt; E[Scenario Runner]\n    E --&gt; F[Request Execution]\n\n    G[Reporting] --&gt; H[Metrics Collection]\n    G --&gt; I[Results Output]\n\n    J[Configuration Files] --&gt; B\n    K[YAML Parser] --&gt; B\n    L[Validation] --&gt; B</code></pre>"},{"location":"dev_guide/#key-design-principles","title":"Key Design Principles","text":"<ol> <li>Extensibility: Easy to add new test scenarios and phases</li> <li>Modularity: Clear separation of concerns between phases, scenarios, and requests</li> <li>Performance: Efficient resource usage with gevent-based concurrency</li> <li>Reliability: Robust error handling and configuration validation</li> </ol>"},{"location":"dev_guide/#adding-new-features","title":"Adding New Features","text":""},{"location":"dev_guide/#1-configuration-extensions","title":"1. Configuration Extensions","text":"<p>To add new configuration options:</p> <pre><code>from gradual.configs.parser import Parser\n\nclass ExtendedParser(Parser):\n    \"\"\"Extended parser with additional configuration options.\"\"\"\n\n    def __init__(self, test_config_file_path: str, request_configs_path: str):\n        super().__init__(test_config_file_path, request_configs_path)\n        # Add custom initialization logic\n\n    def read_configs(self):\n        \"\"\"Read and parse all configuration files with extensions.\"\"\"\n        super().read_configs()\n        # Add custom configuration parsing logic\n</code></pre>"},{"location":"dev_guide/#2-custom-runners","title":"2. Custom Runners","text":"<p>To add new runner types:</p> <pre><code>from gradual.runners.runner import Runner\n\nclass CustomRunner(Runner):\n    \"\"\"Custom runner with additional functionality.\"\"\"\n\n    def __init__(self, scenarios):\n        super().__init__(scenarios)\n        # Initialize custom runner features\n\n    def start_test(self):\n        \"\"\"Start test execution with custom logic.\"\"\"\n        # Add custom pre-execution logic\n        super().start_test()\n        # Add custom post-execution logic\n</code></pre>"},{"location":"dev_guide/#3-enhanced-reporting","title":"3. Enhanced Reporting","text":"<p>To add new reporting features:</p> <pre><code>from gradual.reporting.base import BaseReporter\n\nclass CustomReporter(BaseReporter):\n    \"\"\"Custom reporter implementation.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(config)\n        # Initialize custom reporting features\n\n    def generate_report(self, results):\n        \"\"\"Generate custom report format.\"\"\"\n        # Implementation here\n        pass\n</code></pre>"},{"location":"dev_guide/#configuration-management","title":"Configuration Management","text":""},{"location":"dev_guide/#configuration-schema","title":"Configuration Schema","text":"<p>The framework uses a YAML-based configuration system:</p> <pre><code>from gradual.configs.parser import Parser\n\nclass Parser:\n    \"\"\"Manages test configuration loading and validation.\"\"\"\n\n    def __init__(self, test_config_file_path: str, request_configs_path: str):\n        self.test_config_file_path = test_config_file_path\n        self.request_configs_path = request_configs_path\n        self.phases = []\n        self.run_name = None\n        self.phase_wait = 0\n\n    def read_configs(self):\n        \"\"\"Load and parse configuration files.\"\"\"\n        # Implementation here\n        pass\n</code></pre>"},{"location":"dev_guide/#configuration-file-structure","title":"Configuration File Structure","text":"<p>The framework expects two main configuration files:</p> <ol> <li>Test Configuration: Defines test phases, scenarios, and timing</li> <li>Request Configuration: Defines individual HTTP and WebSocket requests and parameters</li> </ol> <p>Example test configuration:</p> <pre><code>runs:\n  name: \"example_test\"\n  wait_between_phases: 10\n  phases:\n    phase1:\n      run_time: 300\n      scenarios:\n        scenario1:\n          min_concurrency: 10\n          max_concurrency: 100\n          ramp_up_add: 10\n          ramp_up_wait: 1\n          requests: \"FROM_REQUEST_YAML_FILE\"\n          request_file: \"requests.yaml\"\n</code></pre>"},{"location":"dev_guide/#performance-considerations","title":"Performance Considerations","text":""},{"location":"dev_guide/#memory-management","title":"Memory Management","text":"<ul> <li>Use generators for large datasets</li> <li>Implement proper cleanup in runners</li> <li>Monitor memory usage during tests</li> </ul>"},{"location":"dev_guide/#concurrency","title":"Concurrency","text":"<ul> <li>Leverage gevent for efficient I/O</li> <li>Use connection pooling where appropriate</li> <li>Implement rate limiting to prevent overwhelming targets</li> </ul>"},{"location":"dev_guide/#monitoring","title":"Monitoring","text":"<pre><code>import psutil\nimport time\n\nclass PerformanceMonitor:\n    \"\"\"Monitor system performance during tests.\"\"\"\n\n    def __init__(self):\n        self.start_time = time.time()\n        self.start_memory = psutil.virtual_memory().used\n\n    def get_stats(self):\n        \"\"\"Get current performance statistics.\"\"\"\n        current_memory = psutil.virtual_memory().used\n        elapsed_time = time.time() - self.start_time\n\n        return {\n            \"elapsed_time\": elapsed_time,\n            \"memory_used\": current_memory - self.start_memory,\n            \"cpu_percent\": psutil.cpu_percent()\n        }\n</code></pre>"},{"location":"dev_guide/#documentation","title":"Documentation","text":""},{"location":"dev_guide/#code-documentation","title":"Code Documentation","text":"<ul> <li>Use Google-style docstrings</li> <li>Include type hints for all public methods</li> <li>Document exceptions and edge cases</li> </ul> <p>Example:</p> <pre><code>def execute_test_scenario(self, scenario: dict, user_data: dict) -&gt; dict:\n    \"\"\"Execute a test scenario with user data.\n\n    Args:\n        scenario: Scenario configuration dictionary\n        user_data: User-specific data for the scenario\n\n    Returns:\n        Dictionary containing execution results\n\n    Raises:\n        ScenarioExecutionError: If scenario execution fails\n        ValidationError: If response validation fails\n    \"\"\"\n    pass\n</code></pre>"},{"location":"dev_guide/#api-documentation","title":"API Documentation","text":"<ul> <li>Keep API documentation up to date</li> <li>Include usage examples</li> <li>Document breaking changes</li> </ul>"},{"location":"dev_guide/#contributing-guidelines","title":"Contributing Guidelines","text":""},{"location":"dev_guide/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Test thoroughly</li> <li>Update documentation</li> <li>Submit a pull request</li> </ol>"},{"location":"dev_guide/#commit-messages","title":"Commit Messages","text":"<p>Use conventional commit format:</p> <pre><code>feat: add custom runner support\nfix: resolve memory leak in connection pooling\ndocs: update API documentation\ntest: add performance benchmarks\n</code></pre>"},{"location":"dev_guide/#code-review","title":"Code Review","text":"<ul> <li>All changes require review</li> <li>Address feedback promptly</li> <li>Maintain test coverage</li> <li>Follow project standards</li> </ul>"},{"location":"dev_guide/#debugging-and-troubleshooting","title":"Debugging and Troubleshooting","text":""},{"location":"dev_guide/#development-tools","title":"Development Tools","text":"<pre><code># Enable debug logging\nexport GRADUAL_LOG_LEVEL=\"DEBUG\"\n\n# Run with profiling\npython -m cProfile -o profile.stats stress_run.py\n\n# Analyze profile results\npython -c \"import pstats; p = pstats.Stats('profile.stats'); p.sort_stats('cumulative').print_stats(20)\"\n</code></pre>"},{"location":"dev_guide/#common-issues","title":"Common Issues","text":"<ol> <li>Import Errors: Check PYTHONPATH and virtual environment</li> <li>Configuration Issues: Validate YAML syntax and schema</li> <li>Performance Problems: Use profiling tools to identify bottlenecks</li> <li>Memory Issues: Monitor memory usage and implement cleanup</li> </ol>"},{"location":"dev_guide/#release-process","title":"Release Process","text":""},{"location":"dev_guide/#version-management","title":"Version Management","text":"<ul> <li>Use semantic versioning (MAJOR.MINOR.PATCH)</li> <li>Update version in <code>pyproject.toml</code></li> <li>Create release notes</li> <li>Tag releases in Git</li> </ul>"},{"location":"dev_guide/#distribution","title":"Distribution","text":"<pre><code># Build package\nmake build\n\n# Test installation\npip install dist/*.whl\n\n# Upload to PyPI (maintainers only)\nmake publish\n</code></pre>"},{"location":"dev_guide/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: GitHub Issues for bugs and feature requests</li> <li>Discussions: GitHub Discussions for questions and ideas</li> <li>Documentation: This guide and API reference</li> <li>Code: Source code and examples</li> </ul>"},{"location":"dev_guide/#next-steps","title":"Next Steps","text":"<ul> <li>Read the API Reference for detailed technical information</li> <li>Check out Examples for usage patterns</li> <li>Review the User Guide for end-user documentation</li> <li>Join the community discussions</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This page provides real-world examples of using the Gradual stress testing framework.</p>"},{"location":"examples/#sample-configuration-examples","title":"Sample Configuration Examples","text":"<p>These examples are based on the actual configuration files included with Gradual.</p>"},{"location":"examples/#basic-fastapi-test-configuration","title":"Basic FastAPI Test Configuration","text":"<p>This example shows a simple test configuration for a FastAPI application with two scenarios.</p> <p>Test Configuration (<code>test_config.yaml</code>): <pre><code>runs:\n  name: \"Test Run\"\n  wait_between_phases: 10\n  phases:\n    \"phase1\":\n      scenarios:\n        \"scenario1\":\n          requests:\n            - \"request1\"\n            - \"request2\"\n          min_concurrency: 1\n          max_concurrency: 10\n          ramp_up_multiply:\n            - 1\n            - 2\n            - 3\n          ramp_up_wait:\n            - 1\n            - 2\n            - 3\n          iterate_through_requests: true\n        \"scenario2\":\n          requests:\n            - \"request3\"\n          min_concurrency: 1\n          max_concurrency: 10\n          ramp_up_multiply: 1\n          ramp_up_wait: 1\n          iterate_through_requests: true\n      run_time: 10\n</code></pre></p> <p>Request Configuration (<code>request_config.yaml</code>): <pre><code>requests:\n  \"request1\":\n    url: \"http://localhost:8000/ping\"\n    method: \"GET\"\n    expected_response_time: 1\n    auth: null\n  \"request2\":\n    url: \"http://localhost:8000/data\"\n    method: \"GET\"\n    expected_response_time: 1\n    auth: null\n  \"request3\":\n    url: \"http://localhost:8000/submit\"\n    method: \"POST\"\n    expected_response_time: 1\n    auth: null\n    params:\n      name: \"John Doe\"\n      email: \"john.doe@example.com\"\n      age: 30\n      city: \"New York\"\n      country: \"USA\"\n</code></pre></p> <p>What This Test Does: 1. Phase 1 runs for 10 seconds with two scenarios:    - Scenario 1: Tests two GET endpoints (<code>/ping</code> and <code>/data</code>) with ramp-up from 1 to 10 concurrent requests - Scenario 2: Tests a POST endpoint (<code>/submit</code>) with a single concurrent request 2. Ramp-up Strategy: Concurrent requests multiply by 1, 2, then 3, with waits of 1, 2, then 3 seconds 3. Request Iteration: Both scenarios iterate through their requests sequentially</p>"},{"location":"examples/#running-the-example","title":"Running the Example","text":"<pre><code># Navigate to the example directory\ncd examples/fastapi_app\n\n# Run the stress test\nstress-run stress_test_configs/test_config.yaml\n\n# Or specify both config files explicitly\nstress-run stress_test_configs/test_config.yaml --request-config stress_test_configs/request_config.yaml\n</code></pre>"},{"location":"examples/#basic-examples","title":"Basic Examples","text":""},{"location":"examples/#simple-http-api-test","title":"Simple HTTP API Test","text":"<pre><code># simple_api_test.yaml\nruns:\n  name: \"Simple API Test\"\n  wait_between_phases: 0\n  phases:\n    \"api_test\":\n      run_time: 120\n      scenarios:\n        \"get_posts\":\n          requests:\n            - \"get_post\"\n          min_concurrency: 1\n          max_concurrency: 50\n          ramp_up_add: 10\n          ramp_up_wait: 30\n          iterate_through_requests: false\n</code></pre> <p>Request Configuration (<code>requests.yaml</code>): <pre><code>requests:\n  \"get_post\":\n    url: \"https://jsonplaceholder.typicode.com/posts/1\"\n    method: \"GET\"\n    expected_response_time: 1000\n    auth: null\n    params: {}\n</code></pre></p>"},{"location":"examples/#multi-scenario-test","title":"Multi-Scenario Test","text":"<pre><code># multi_scenario_test.yaml\nruns:\n  name: \"E-commerce API Test\"\n  wait_between_phases: 5\n  phases:\n    \"browse_phase\":\n      run_time: 300\n      scenarios:\n        \"browse_products\":\n          requests:\n            - \"get_products\"\n          min_concurrency: 10\n          max_concurrency: 100\n          ramp_up_add: 20\n          ramp_up_wait: 60\n          iterate_through_requests: false\n\n    \"cart_phase\":\n      run_time: 300\n      scenarios:\n        \"add_to_cart\":\n          requests:\n            - \"add_cart_item\"\n          min_concurrency: 5\n          max_concurrency: 50\n          ramp_up_add: 10\n          ramp_up_wait: 60\n          iterate_through_requests: false\n</code></pre> <p>Request Configuration (<code>ecommerce_requests.yaml</code>): <pre><code>requests:\n  \"get_products\":\n    url: \"https://api.ecommerce.com/products\"\n    method: \"GET\"\n    expected_response_time: 2000\n    auth: null\n    params:\n      category: \"electronics\"\n      page: \"1\"\n\n  \"add_cart_item\":\n    url: \"https://api.ecommerce.com/cart/add\"\n    method: \"POST\"\n    expected_response_time: 3000\n    auth: \"Bearer {{auth_token}}\"\n    params:\n      product_id: \"prod_001\"\n      quantity: 1\n</code></pre></p>"},{"location":"examples/#advanced-examples","title":"Advanced Examples","text":""},{"location":"examples/#authentication-testing","title":"Authentication Testing","text":"<pre><code># auth_test.yaml\nruns:\n  name: \"Authentication Test\"\n  wait_between_phases: 10\n  phases:\n    \"login_test\":\n      run_time: 180\n      scenarios:\n        \"valid_login\":\n          requests:\n            - \"login_valid\"\n          min_concurrency: 5\n          max_concurrency: 50\n          ramp_up_add: 10\n          ramp_up_wait: 30\n          iterate_through_requests: false\n\n        \"invalid_login\":\n          requests:\n            - \"login_invalid\"\n          min_concurrency: 2\n          max_concurrency: 20\n          ramp_up_add: 5\n          ramp_up_wait: 30\n          iterate_through_requests: false\n\n    \"protected_endpoints\":\n      run_time: 180\n      scenarios:\n        \"user_profile\":\n          requests:\n            - \"get_profile\"\n          min_concurrency: 10\n          max_concurrency: 100\n          ramp_up_add: 20\n          ramp_up_wait: 30\n          iterate_through_requests: false\n</code></pre> <p>Request Configuration (<code>auth_requests.yaml</code>): <pre><code>requests:\n  \"login_valid\":\n    url: \"https://api.example.com/auth/login\"\n    method: \"POST\"\n    expected_response_time: 2000\n    auth: null\n    params:\n      username: \"user1\"\n      password: \"pass1\"\n\n  \"login_invalid\":\n    url: \"https://api.example.com/auth/login\"\n    method: \"POST\"\n    expected_response_time: 2000\n    auth: null\n    params:\n      username: \"invalid\"\n      password: \"wrong\"\n\n  \"get_profile\":\n    url: \"https://api.example.com/users/profile\"\n    method: \"GET\"\n    expected_response_time: 1500\n    auth: \"Bearer {{auth_token}}\"\n    params: {}\n</code></pre></p>"},{"location":"examples/#database-testing","title":"Database Testing","text":"<pre><code># database_test.yaml\nruns:\n  name: \"Database Performance Test\"\n  wait_between_phases: 15\n  phases:\n    \"read_operations\":\n      run_time: 300\n      scenarios:\n        \"user_reads\":\n          requests:\n            - \"get_user\"\n          min_concurrency: 20\n          max_concurrency: 200\n          ramp_up_add: 40\n          ramp_up_wait: 60\n          iterate_through_requests: false\n\n    \"write_operations\":\n      run_time: 300\n      scenarios:\n        \"user_creation\":\n          requests:\n            - \"create_user\"\n          min_concurrency: 5\n          max_concurrency: 50\n          ramp_up_add: 10\n          ramp_up_wait: 60\n          iterate_through_requests: false\n</code></pre> <p>Request Configuration (<code>db_requests.yaml</code>): <pre><code>requests:\n  \"get_user\":\n    url: \"https://api.example.com/users/{{user_id}}\"\n    method: \"GET\"\n    expected_response_time: 500\n    auth: \"Bearer {{auth_token}}\"\n    params: {}\n\n  \"create_user\":\n    url: \"https://api.example.com/users\"\n    method: \"POST\"\n    expected_response_time: 1000\n    auth: \"Bearer {{admin_token}}\"\n    params:\n      username: \"newuser1\"\n      email: \"new1@example.com\"\n      role: \"user\"\n</code></pre></p>"},{"location":"examples/#performance-testing-examples","title":"Performance Testing Examples","text":""},{"location":"examples/#load-testing-with-ramp-up","title":"Load Testing with Ramp-up","text":"<pre><code># ramp_up_test.yaml\nruns:\n  name: \"Ramp-up Load Test\"\n  wait_between_phases: 0\n  phases:\n    \"health_check\":\n      run_time: 1800  # 30 minutes\n      scenarios:\n        \"api_health\":\n          requests:\n            - \"health_endpoint\"\n          min_concurrency: 10\n          max_concurrency: 1000\n          ramp_up_add: 100\n          ramp_up_wait: 900  # 15 minutes ramp-up\n          iterate_through_requests: false\n</code></pre> <p>Request Configuration (<code>health_requests.yaml</code>): <pre><code>requests:\n  \"health_endpoint\":\n    url: \"https://api.example.com/health\"\n    method: \"GET\"\n    expected_response_time: 100\n    auth: null\n    params: {}\n</code></pre></p>"},{"location":"examples/#stress-testing","title":"Stress Testing","text":"<pre><code># stress_test.yaml\nruns:\n  name: \"Stress Test\"\n  wait_between_phases: 0\n  phases:\n    \"heavy_operations\":\n      run_time: 600  # 10 minutes\n      scenarios:\n        \"complex_processing\":\n          requests:\n            - \"process_data\"\n          min_concurrency: 50\n          max_concurrency: 500\n          ramp_up_add: 100\n          ramp_up_wait: 60\n          iterate_through_requests: false\n</code></pre> <p>Request Configuration (<code>stress_requests.yaml</code>): <pre><code>requests:\n  \"process_data\":\n    url: \"https://api.example.com/process\"\n    method: \"POST\"\n    expected_response_time: 10000  # 10 seconds\n    auth: \"Bearer {{auth_token}}\"\n    params:\n      data: \"large_dataset\"\n      operation: \"complex_calculation\"\n</code></pre></p>"},{"location":"examples/#custom-extensions-examples","title":"Custom Extensions Examples","text":""},{"location":"examples/#custom-configuration-parser","title":"Custom Configuration Parser","text":"<pre><code># custom_parser.py\nfrom gradual.configs.parser import Parser\nimport yaml\n\nclass ExtendedParser(Parser):\n    \"\"\"Extended parser with additional configuration options.\"\"\"\n\n    def __init__(self, test_config_file_path: str, request_configs_path: str):\n        super().__init__(test_config_file_path, request_configs_path)\n        self.custom_options = {}\n\n    def read_configs(self):\n        \"\"\"Read and parse configuration files with custom extensions.\"\"\"\n        super().read_configs()\n\n        # Read custom configuration options\n        with open(self.test_config_file_path, \"r\") as config_file:\n            config_data = yaml.safe_load(config_file)\n            self.custom_options = config_data.get(\"custom_options\", {})\n\n    def get_custom_option(self, key: str, default=None):\n        \"\"\"Get custom configuration option.\"\"\"\n        return self.custom_options.get(key, default)\n</code></pre>"},{"location":"examples/#custom-runner","title":"Custom Runner","text":"<pre><code># custom_runner.py\nfrom gradual.runners.runner import Runner\nimport logging\n\nclass LoggingRunner(Runner):\n    \"\"\"Custom runner with enhanced logging.\"\"\"\n\n    def __init__(self, scenarios):\n        super().__init__(scenarios)\n        self.logger = logging.getLogger(__name__)\n        self.request_count = 0\n\n    def start_test(self):\n        \"\"\"Start test execution with enhanced logging.\"\"\"\n        self.logger.info(f\"Starting test with {len(self.scenarios)} scenarios\")\n        self.logger.info(f\"Total expected requests: {self._calculate_total_requests()}\")\n\n        super().start_test()\n\n        self.logger.info(f\"Test completed. Total requests processed: {self.request_count}\")\n\n    def _calculate_total_requests(self):\n        \"\"\"Calculate total expected requests across all scenarios.\"\"\"\n        total = 0\n        for scenario in self.scenarios:\n            # This is a simplified calculation - actual implementation would be more complex\n            total += scenario.max_concurrency * scenario.runtime\n        return total\n</code></pre>"},{"location":"examples/#integration-examples","title":"Integration Examples","text":""},{"location":"examples/#cicd-pipeline-integration","title":"CI/CD Pipeline Integration","text":"<pre><code># .github/workflows/stress-test.yml\nname: \"Stress Testing\"\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  stress-test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.10'\n\n    - name: Install dependencies\n      run: |\n        pip install -e \".[dev]\"\n\n    - name: Run stress tests\n      run: |\n        stress-run --test_config tests/stress/api_test.yaml --request_config tests/stress/requests.yaml\n\n    - name: Generate report\n      run: |\n        stress-run --test_config tests/stress/api_test.yaml --request_config tests/stress/requests.yaml\n\n    - name: Upload report\n      uses: actions/upload-artifact@v3\n      with:\n        name: stress-test-report\n        path: ./reports\n</code></pre>"},{"location":"examples/#docker-integration","title":"Docker Integration","text":"<pre><code># Dockerfile\nFROM python:3.10-slim\n\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    gcc \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Copy requirements and install Python dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY . .\n\n# Install Gradual\nRUN pip install -e \".[dev]\"\n\n# Expose ports\nEXPOSE 8080\n\n# Default command\nCMD [\"python\", \"-m\", \"gradual.main\"]\n</code></pre> <pre><code># docker-compose.yml\nversion: '3.8'\n\nservices:\n  gradual:\n    build: .\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - ./tests:/app/tests\n      - ./results:/app/results\n    environment:\n      - GRADUAL_LOG_LEVEL=INFO\n    command: [\"python\", \"-m\", \"gradual.main\"]\n</code></pre>"},{"location":"examples/#monitoring-and-reporting","title":"Monitoring and Reporting","text":""},{"location":"examples/#custom-metrics-collection","title":"Custom Metrics Collection","text":"<pre><code># custom_metrics.py\nimport time\nfrom dataclasses import dataclass\nfrom typing import Dict, Any\n\n@dataclass\nclass TestMetrics:\n    \"\"\"Custom metrics collection for test runs.\"\"\"\n    start_time: float\n    end_time: float = 0\n    total_requests: int = 0\n    successful_requests: int = 0\n    failed_requests: int = 0\n    total_response_time: float = 0\n\n    def record_request(self, success: bool, response_time: float):\n        \"\"\"Record a single request result.\"\"\"\n        self.total_requests += 1\n        if success:\n            self.successful_requests += 1\n        else:\n            self.failed_requests += 1\n        self.total_response_time += response_time\n\n    def finalize(self):\n        \"\"\"Finalize metrics collection.\"\"\"\n        self.end_time = time.time()\n\n    def get_summary(self) -&gt; Dict[str, Any]:\n        \"\"\"Get metrics summary.\"\"\"\n        duration = self.end_time - self.start_time\n        avg_response_time = self.total_response_time / self.total_requests if self.total_requests &gt; 0 else 0\n\n        return {\n            \"duration_seconds\": duration,\n            \"total_requests\": self.total_requests,\n            \"successful_requests\": self.successful_requests,\n            \"failed_requests\": self.failed_requests,\n            \"success_rate\": self.successful_requests / self.total_requests if self.total_requests &gt; 0 else 0,\n            \"average_response_time\": avg_response_time,\n            \"requests_per_second\": self.total_requests / duration if duration &gt; 0 else 0\n        }\n</code></pre>"},{"location":"examples/#simple-dashboard","title":"Simple Dashboard","text":"<pre><code># simple_dashboard.py\nimport time\nfrom typing import Dict, Any\nfrom custom_metrics import TestMetrics\n\nclass SimpleDashboard:\n    \"\"\"Simple real-time dashboard for monitoring test progress.\"\"\"\n\n    def __init__(self):\n        self.metrics = TestMetrics(start_time=time.time())\n        self.running = True\n\n    def update_metrics(self, success: bool, response_time: float):\n        \"\"\"Update metrics with new request data.\"\"\"\n        self.metrics.record_request(success, response_time)\n\n    def display_status(self):\n        \"\"\"Display current test status.\"\"\"\n        if not self.running:\n            return\n\n        summary = self.metrics.get_summary()\n        print(f\"\\n=== Test Status ===\")\n        print(f\"Duration: {summary['duration_seconds']:.1f}s\")\n        print(f\"Total Requests: {summary['total_requests']}\")\n        print(f\"Success Rate: {summary['success_rate']:.2%}\")\n        print(f\"Avg Response Time: {summary['average_response_time']:.3f}s\")\n        print(f\"Requests/sec: {summary['requests_per_second']:.1f}\")\n        print(\"=\" * 20)\n\n    def stop(self):\n        \"\"\"Stop the dashboard.\"\"\"\n        self.running = False\n        self.metrics.finalize()\n        print(\"\\n=== Final Results ===\")\n        final_summary = self.metrics.get_summary()\n        for key, value in final_summary.items():\n            if isinstance(value, float):\n                print(f\"{key}: {value:.3f}\")\n            else:\n                print(f\"{key}: {value}\")\n</code></pre>"},{"location":"examples/#best-practices","title":"Best Practices","text":""},{"location":"examples/#test-design","title":"Test Design","text":"<ol> <li>Realistic Scenarios: Model real user behavior</li> <li>Data Variation: Use different data sets</li> <li>Ramp-up Strategy: Start with low concurrency and gradually increase</li> <li>Error Handling: Test both success and failure scenarios</li> </ol>"},{"location":"examples/#environment-setup","title":"Environment Setup","text":"<ol> <li>Isolation: Use dedicated test environments</li> <li>Monitoring: Set up comprehensive monitoring</li> <li>Cleanup: Implement data cleanup procedures</li> <li>Backup: Have rollback plans</li> </ol>"},{"location":"examples/#analysis","title":"Analysis","text":"<ol> <li>Baselines: Establish performance baselines</li> <li>Trends: Monitor performance over time</li> <li>Bottlenecks: Identify and document bottlenecks</li> <li>Documentation: Document findings and recommendations</li> </ol>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference for detailed technical information</li> <li>Read the User Guide for comprehensive usage instructions</li> <li>Check the Development Guide for contribution guidelines</li> <li>Join the community discussions</li> </ul>"},{"location":"getting_started/","title":"Getting Started Guide","text":"<p>Welcome to Gradual! This guide will help you run your first stress test and understand the basic concepts. By the end of this guide, you'll have successfully executed a load test and viewed the results.</p>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>\u2705 Gradual installed - Follow the Installation Guide if you haven't installed it yet</li> <li>\u2705 A target application - A web service, API, or application to test</li> <li>\u2705 Basic understanding - Familiarity with HTTP requests and YAML configuration</li> </ul>"},{"location":"getting_started/#quick-start-your-first-test","title":"Quick Start: Your First Test","text":""},{"location":"getting_started/#step-1-create-a-simple-test-configuration","title":"Step 1: Create a Simple Test Configuration","text":"<p>Create a file named <code>first_test.yaml</code> with the following content:</p> <pre><code>name: \"My First Stress Test\"\ndescription: \"A simple test to get started with Gradual\"\n\ntarget:\n  base_url: \"https://httpbin.org\"\n  protocol: \"http\"\n\nscenarios:\n  - name: \"Get Request\"\n    weight: 100\n    steps:\n      - request:\n          method: \"GET\"\n          path: \"/get\"\n        assertions:\n          - status_code: 200\n          - response_time: \"&lt; 2000ms\"\n\nload:\n  users: 10\n  duration: 60\n  ramp_up: 10\n</code></pre> <p>Note: We're using <code>httpbin.org</code> as a test target since it's a public service designed for testing HTTP requests.</p>"},{"location":"getting_started/#step-2-run-your-first-test","title":"Step 2: Run Your First Test","text":"<p>Open a terminal and run:</p> <pre><code>stress-run first_test.yaml\n</code></pre> <p>You should see output similar to:</p> <pre><code>\ud83d\ude80 Starting stress test: My First Stress Test\n\ud83d\udcca Target: https://httpbin.org\n\ud83d\udc65 Users: 10 | Duration: 60s | Ramp-up: 10s\n\u23f1\ufe0f  Test started at 2024-01-15 10:30:00\n\n[\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588] 100% | 60s elapsed\n\u2705 Test completed successfully!\n\n\ud83d\udcc8 Results Summary:\n   Total Requests: 1,200\n   Successful: 1,200 (100.0%)\n   Failed: 0 (0.0%)\n   Average Response Time: 245ms\n   95th Percentile: 456ms\n   Requests/Second: 20.0\n</code></pre>"},{"location":"getting_started/#step-3-view-real-time-results","title":"Step 3: View Real-time Results","text":"<p>In another terminal, start the dashboard to monitor your test in real-time:</p> <pre><code>stress-dashboard --mode bokeh --port 8080\n</code></pre> <p>Open your browser and navigate to <code>http://localhost:8080</code> to see live metrics.</p>"},{"location":"getting_started/#understanding-the-test-configuration","title":"Understanding the Test Configuration","text":"<p>Let's break down the key components of your test configuration:</p>"},{"location":"getting_started/#test-metadata","title":"Test Metadata","text":"<pre><code>name: \"My First Stress Test\"        # Name of your test\ndescription: \"A simple test...\"     # Description for documentation\n</code></pre>"},{"location":"getting_started/#target-configuration","title":"Target Configuration","text":"<pre><code>target:\n  base_url: \"https://httpbin.org\"   # The system you're testing\n  protocol: \"http\"                  # Protocol to use\n</code></pre>"},{"location":"getting_started/#test-scenarios","title":"Test Scenarios","text":"<pre><code>scenarios:\n  - name: \"Get Request\"             # Name of this test scenario\n    weight: 100                     # Relative frequency (100 = 100%)\n    steps:                          # List of actions to perform\n      - request:                    # HTTP request configuration\n          method: \"GET\"             # HTTP method\n          path: \"/get\"              # Path relative to base_url\n</code></pre>"},{"location":"getting_started/#load-configuration","title":"Load Configuration","text":"<pre><code>load:\n  users: 10                        # Number of concurrent users\n  duration: 60                     # Test duration in seconds\n  ramp_up: 10                      # Time to gradually increase users\n</code></pre>"},{"location":"getting_started/#creating-your-own-test","title":"Creating Your Own Test","text":"<p>Now let's create a test for your own application. Here's a template:</p> <pre><code>name: \"My Application Test\"\ndescription: \"Testing my web application\"\n\ntarget:\n  base_url: \"http://localhost:3000\"  # Change this to your app's URL\n  protocol: \"http\"\n\nscenarios:\n  - name: \"Homepage Load\"\n    weight: 50\n    steps:\n      - request:\n          method: \"GET\"\n          path: \"/\"\n        assertions:\n          - status_code: 200\n          - response_time: \"&lt; 1000ms\"\n\n  - name: \"API Endpoint\"\n    weight: 50\n    steps:\n      - request:\n          method: \"POST\"\n          path: \"/api/data\"\n          headers:\n            Content-Type: \"application/json\"\n          body:\n            key: \"value\"\n        assertions:\n          - status_code: 200\n          - response_time: \"&lt; 500ms\"\n\nload:\n  users: 20\n  duration: 120\n  ramp_up: 30\n</code></pre>"},{"location":"getting_started/#running-tests","title":"Running Tests","text":"<p>Run your stress tests using the CLI:</p> <pre><code># Run with both configuration files\nstress-run --test_config my_test.yaml --request_config requests.yaml\n\n# Run with only test configuration (requests defined inline)\nstress-run --test_config my_test.yaml\n\n# Run with relative paths\nstress-run --test_config ./configs/test.yaml --request_config ./configs/requests.yaml\n</code></pre> <p>\u26a0\ufe0f Note: All test parameters must be defined in the YAML configuration files. The CLI does not support command-line overrides.</p>"},{"location":"getting_started/#monitoring-your-tests","title":"Monitoring Your Tests","text":""},{"location":"getting_started/#real-time-dashboard","title":"Real-time Dashboard","text":"<p>The dashboard provides live monitoring:</p> <pre><code># Start Bokeh dashboard (interactive charts)\nstress-dashboard --mode bokeh --port 8080\n\n# Start WebSocket dashboard (lightweight)\nstress-dashboard --mode websocket --port 8081\n\n# Start with custom host\nstress-dashboard --mode bokeh --host 0.0.0.0 --port 8080\n</code></pre>"},{"location":"getting_started/#key-metrics-to-watch","title":"Key Metrics to Watch","text":"<ul> <li>Response Time: How fast your application responds</li> <li>Throughput: Requests per second</li> <li>Error Rate: Percentage of failed requests</li> <li>Active Users: Current load on your system</li> </ul>"},{"location":"getting_started/#common-test-patterns","title":"Common Test Patterns","text":""},{"location":"getting_started/#1-smoke-test-light-load","title":"1. Smoke Test (Light Load)","text":"<pre><code>load:\n  users: 5\n  duration: 60\n  ramp_up: 10\n</code></pre>"},{"location":"getting_started/#2-load-test-normal-load","title":"2. Load Test (Normal Load)","text":"<pre><code>load:\n  users: 50\n  duration: 300\n  ramp_up: 60\n</code></pre>"},{"location":"getting_started/#3-stress-test-high-load","title":"3. Stress Test (High Load)","text":"<pre><code>load:\n  users: 200\n  duration: 600\n  ramp_up: 120\n</code></pre>"},{"location":"getting_started/#4-spike-test-sudden-load","title":"4. Spike Test (Sudden Load)","text":"<pre><code>load:\n  users: 100\n  duration: 180\n  ramp_up: 10  # Quick ramp-up for spike effect\n</code></pre>"},{"location":"getting_started/#best-practices-for-beginners","title":"Best Practices for Beginners","text":""},{"location":"getting_started/#1-start-small","title":"1. Start Small","text":"<ul> <li>Begin with a small number of users (5-10)</li> <li>Use short durations (1-2 minutes)</li> <li>Gradually increase load</li> </ul>"},{"location":"getting_started/#2-test-in-isolation","title":"2. Test in Isolation","text":"<ul> <li>Use dedicated test environments</li> <li>Avoid testing production systems initially</li> <li>Clean up test data after runs</li> </ul>"},{"location":"getting_started/#3-monitor-everything","title":"3. Monitor Everything","text":"<ul> <li>Watch your target application's performance</li> <li>Monitor system resources (CPU, memory, network)</li> <li>Use the dashboard for real-time insights</li> </ul>"},{"location":"getting_started/#4-validate-results","title":"4. Validate Results","text":"<ul> <li>Check that assertions are passing</li> <li>Verify response times are reasonable</li> <li>Ensure error rates are acceptable</li> </ul>"},{"location":"getting_started/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"getting_started/#test-wont-start","title":"Test Won't Start","text":"<pre><code># Check if Gradual is installed\nstress-run --version\n\n# Verify your YAML syntax\npython -c \"import yaml; yaml.safe_load(open('test.yaml'))\"\n</code></pre>"},{"location":"getting_started/#high-error-rates","title":"High Error Rates","text":"<pre><code># Check if target is accessible\ncurl http://localhost:3000\n\n# Run with debug mode\nstress-run test.yaml --debug --verbose\n</code></pre>"},{"location":"getting_started/#dashboard-not-loading","title":"Dashboard Not Loading","text":"<pre><code># Check if port is available\nnetstat -tulpn | grep 8080\n\n# Try different port\nstress-dashboard --mode bokeh --port 8081\n</code></pre>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've successfully run your first stress test. Here's what to explore next:</p> <ol> <li>Read the User Guide for advanced features and detailed configuration</li> <li>Check out Examples for real-world test scenarios</li> <li>Learn about Custom Protocol Handlers for specialized testing</li> <li>Explore Distributed Testing for large-scale tests</li> <li>Dive into the Configuration Reference for comprehensive configuration options and examples</li> </ol> <p>\ud83d\udca1 Tip: Use the Configuration tab in the navigation for quick access to all configuration options and best practices.</p>"},{"location":"getting_started/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Browse the complete documentation</li> <li>Examples: Study the example configurations</li> <li>Community: Join discussions on GitHub</li> <li>Issues: Report bugs or request features</li> </ul> <p>Happy testing! \ud83d\ude80</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide covers everything you need to install and set up Gradual for stress testing your applications and systems.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing Gradual, ensure you have the following:</p> <ul> <li>Python 3.9 or higher - Gradual requires Python 3.9+ for modern language features</li> <li>pip package manager - For installing Python packages</li> <li>Git - For cloning the repository (if installing from source)</li> <li>System dependencies - May vary based on your operating system</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-install-from-source-recommended-for-development","title":"Method 1: Install from Source (Recommended for Development)","text":"<pre><code># Clone the repository\ngit clone https://github.com/Gradual-Load-Testing/gradual.git\ncd gradual\n\n# Install in development mode with core features\npip install -e \".[dev,bokeh,websockets]\"\n</code></pre>"},{"location":"installation/#method-2-install-from-pypi-coming-soon","title":"Method 2: Install from PyPI (Coming Soon)","text":"<pre><code># Install the latest stable version\npip install gradual-load-testing\n\n# Install with all optional dependencies\npip install gradual-load-testing[all]\n</code></pre>"},{"location":"installation/#method-3-install-in-virtual-environment-recommended-for-production","title":"Method 3: Install in Virtual Environment (Recommended for Production)","text":"<pre><code># Create a virtual environment\npython -m venv gradual-env\n\n# Activate the virtual environment\n# On Linux/macOS:\nsource gradual-env/bin/activate\n# On Windows:\ngradual-env\\Scripts\\activate\n\n# Install Gradual\npip install -e \".[dev,bokeh,websockets]\"\n</code></pre>"},{"location":"installation/#dependency-management","title":"Dependency Management","text":""},{"location":"installation/#core-dependencies","title":"Core Dependencies","text":"<p>The following dependencies are automatically installed with the core package:</p> <ul> <li>gevent \u2013 High-performance asynchronous I/O and concurrency</li> <li>requests \u2013 User-friendly HTTP client for Python</li> </ul>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>Install additional features by specifying extra dependencies:</p> <pre><code># For kerb and oidc (coming soon) authentication support\npip install -e \".[auth]\"\n\n# For distributed testing across multiple machines\npip install -e \".[distributed]\"\n\n# For advanced metrics collection and analysis\npip install -e \".[metrics]\"\n\n# For all optional features\npip install -e \".[all]\"\n</code></pre>"},{"location":"installation/#development-dependencies","title":"Development Dependencies","text":"<p>For contributing to Gradual or running tests:</p> <pre><code># Install development dependencies\npip install -e \".[dev]\"\n\n# This includes:\n# - pytest for testing\n# - black for code formatting\n# - flake8 for linting\n# - mypy for type checking\n# - pre-commit for git hooks\n</code></pre>"},{"location":"installation/#platform-specific-installation","title":"Platform-Specific Installation","text":""},{"location":"installation/#linux-ubuntudebian","title":"Linux (Ubuntu/Debian)","text":"<pre><code># Update package list\nsudo apt update\n\n# Install system dependencies\nsudo apt install python3-pip python3-venv git\n\n# Install Gradual\npip3 install -e \".[dev,bokeh,websockets]\"\n</code></pre>"},{"location":"installation/#linux-centosrhelfedora","title":"Linux (CentOS/RHEL/Fedora)","text":"<pre><code># Install system dependencies\nsudo yum install python3-pip python3-venv git\n# or for newer versions:\nsudo dnf install python3-pip python3-venv git\n\n# Install Gradual\npip3 install -e \".[dev,bokeh,websockets]\"\n</code></pre>"},{"location":"installation/#macos","title":"macOS","text":"<pre><code># Install Homebrew if not already installed\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install Python and Git\nbrew install python git\n\n# Install Gradual\npip3 install -e \".[dev,bokeh,websockets]\"\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<pre><code># Install Python from https://python.org\n# Install Git from https://git-scm.com\n\n# Open Command Prompt or PowerShell\npip install -e \".[dev,bokeh,websockets]\"\n</code></pre>"},{"location":"installation/#docker-installation","title":"Docker Installation","text":"<p>If you prefer using Docker:</p> <pre><code># Pull the official image (when available)\ndocker pull gradual/gradual:latest\n\n# Run a container\ndocker run -it --rm gradual/gradual:latest stress-run --help\n\n# Mount your test configurations\ndocker run -it --rm -v $(pwd):/tests gradual/gradual:latest stress-run --test_config /tests/my_test.yaml --request_config /tests/requests.yaml\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>After installation, verify that Gradual is working correctly:</p> <pre><code># Check if stress-run command is available\nstress-run --version\n\n# Check if stress-dashboard command is available\nstress-dashboard --version\n\n# Run a simple test to verify functionality\nstress-run --help\n</code></pre>"},{"location":"installation/#troubleshooting-installation","title":"Troubleshooting Installation","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#permission-errors","title":"Permission Errors","text":"<pre><code># Use --user flag to install in user directory\npip install --user -e \".[dev,bokeh,websockets]\"\n\n# Or use sudo (not recommended for production)\nsudo pip install -e \".[dev,bokeh,websockets]\"\n</code></pre>"},{"location":"installation/#python-version-issues","title":"Python Version Issues","text":"<pre><code># Check your Python version\npython --version\npython3 --version\n\n# Use specific Python version\npython3.9 -m pip install -e \".[dev,bokeh,websockets]\"\n</code></pre>"},{"location":"installation/#dependency-conflicts","title":"Dependency Conflicts","text":"<pre><code># Create a fresh virtual environment\npython -m venv fresh-env\nsource fresh-env/bin/activate  # Linux/macOS\n# fresh-env\\Scripts\\activate  # Windows\n\n# Install with --no-deps to avoid conflicts\npip install -e \".[dev,bokeh,websockets]\" --no-deps\n</code></pre>"},{"location":"installation/#network-issues","title":"Network Issues","text":"<pre><code># Use alternative package index\npip install -e \".[dev,bokeh,websockets]\" -i https://pypi.org/simple/\n\n# Or use a mirror\npip install -e \".[dev,bokeh,websockets]\" -i https://pypi.tuna.tsinghua.edu.cn/simple/\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Read the Getting Started Guide to run your first test</li> <li>Explore the User Guide for detailed usage information</li> <li>Check out Examples for real-world use cases</li> <li>Join the community for support and discussions</li> </ol>"},{"location":"installation/#support","title":"Support","text":"<p>If you encounter installation issues:</p> <ul> <li>Check the GitHub Issues</li> <li>Review the Troubleshooting section</li> <li>Join the community discussions</li> </ul>"},{"location":"quick_start/","title":"Quick Start Guide","text":"<p>Get up and running with Gradual stress testing in minutes using the included sample configurations.</p>"},{"location":"quick_start/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>pip package manager</li> <li>Basic knowledge of YAML configuration files</li> </ul>"},{"location":"quick_start/#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/Gradual-Load-Testing/gradual.git\ncd gradual\n\n# Install Gradual with development dependencies\npip install -e \".[dev,bokeh,websockets]\"\n</code></pre>"},{"location":"quick_start/#your-first-stress-test","title":"Your First Stress Test","text":"<p>Gradual comes with sample configuration files that you can use immediately to test your understanding.</p>"},{"location":"quick_start/#1-explore-the-sample-configuration","title":"1. Explore the Sample Configuration","text":"<p>Navigate to the examples directory:</p> <pre><code>cd examples/fastapi_app/stress_test_configs\n</code></pre> <p>You'll find two files:</p> <ul> <li><code>test_config.yaml</code> - Defines the test structure</li> <li><code>request_config.yaml</code> - Defines the HTTP and WebSocket requests</li> </ul>"},{"location":"quick_start/#2-understand-the-configuration","title":"2. Understand the Configuration","text":"<p>Test Configuration (<code>test_config.yaml</code>): <pre><code>runs:\n  name: \"Test Run\"\n  wait_between_phases: 10\n  phases:\n    \"phase1\":\n      scenarios:\n        \"scenario1\":\n          requests:\n            - \"request1\"\n            - \"request2\"\n          min_concurrency: 1\n          max_concurrency: 10\n          ramp_up_multiply: [1, 2, 3]\n          ramp_up_wait: [1, 2, 3]\n          iterate_through_requests: true\n      run_time: 10\n</code></pre></p> <p>Request Configuration (<code>request_config.yaml</code>): <pre><code>requests:\n  \"request1\":\n    url: \"http://localhost:8000/ping\"\n    method: \"GET\"\n    expected_response_time: 1\n    auth: null\n  \"request2\":\n    url: \"http://localhost:8000/data\"\n    method: \"GET\"\n    expected_response_time: 1\n    auth: null\n</code></pre></p>"},{"location":"quick_start/#3-run-your-first-test","title":"3. Run Your First Test","text":"<pre><code># From the examples/fastapi_app directory\nstress-run --test_config stress_test_configs/test_config.yaml\n</code></pre> <p>What Happens:</p> <ol> <li>Gradual reads the test configuration</li> <li>Starts with 1 concurrent request</li> <li>Ramp-up: 1 \u2192 2 \u2192 3 concurrent requests (waiting 1, 2, 3 seconds between steps)</li> <li>Runs for 10 seconds</li> <li>Tests two endpoints: <code>/ping</code> and <code>/data</code></li> </ol>"},{"location":"quick_start/#4-monitor-the-test","title":"4. Monitor the Test","text":"<p>Open another terminal and start the monitoring dashboard:</p> <pre><code>stress-dashboard --mode bokeh --port 8080\n</code></pre> <p>Then open your browser to <code>http://localhost:8080</code> to see real-time metrics.</p>"},{"location":"quick_start/#understanding-the-results","title":"Understanding the Results","text":"<p>After the test completes, you'll see:</p> <ul> <li>Total Requests: Number of requests made</li> <li>Success Rate: Percentage of successful requests</li> <li>Response Times: Average, 95<sup>th</sup> percentile, 99<sup>th</sup> percentile</li> <li>Throughput: Requests per second</li> <li>Error Details: Any failed requests and their reasons</li> </ul>"},{"location":"quick_start/#customizing-your-test","title":"Customizing Your Test","text":""},{"location":"quick_start/#modify-the-sample-configuration","title":"Modify the Sample Configuration","text":"<ol> <li> <p>Change the target URL in <code>request_config.yaml</code>: <pre><code>requests:\n  \"request1\":\n    url: \"https://your-api.com/health\"  # Change this\n    method: \"GET\"\n    expected_response_time: 1\n    auth: null\n</code></pre></p> </li> <li> <p>Adjust the load in <code>test_config.yaml</code>: <pre><code>scenarios:\n  \"scenario1\":\n    min_concurrency: 1\n    max_concurrency: 50        # Increase this\n    ramp_up_multiply: [1, 5, 10, 25, 50]  # More gradual ramp-up\n    ramp_up_wait: [10, 10, 10, 10, 10]    # Longer waits\n</code></pre></p> </li> <li> <p>Add more requests: <pre><code>requests:\n  \"request1\":\n    url: \"https://your-api.com/health\"\n    method: \"GET\"\n    expected_response_time: 1\n    auth: null\n  \"request2\":\n    url: \"https://your-api.com/endpoints\"\n    method: \"GET\"\n    expected_response_time: 2\n    auth: null\n  \"request3\":\n    url: \"https://your-api.com/submit\"\n    method: \"POST\"\n    expected_response_time: 3\n    auth: null\n    params:\n      name: \"Test User\"\n      email: \"test@example.com\"\n</code></pre></p> </li> </ol>"},{"location":"quick_start/#test-different-load-patterns","title":"Test Different Load Patterns","text":""},{"location":"quick_start/#spike-test-sudden-load-increase","title":"Spike Test (sudden load increase):","text":"<pre><code>scenarios:\n  \"spike_test\":\n    min_concurrency: 1\n    max_concurrency: 100\n    ramp_up_multiply: [1, 100]  # Jump from 1 to 100 concurrent requests\n    ramp_up_wait: [0, 0]        # No wait between steps\n    iterate_through_requests: true\n</code></pre>"},{"location":"quick_start/#gradual-ramp-up-steady-increase","title":"Gradual Ramp-up (steady increase):","text":"<pre><code>scenarios:\n  \"gradual_test\":\n    min_concurrency: 1\n    max_concurrency: 50\n    ramp_up_multiply: [1, 2, 5, 10, 25, 50]\n    ramp_up_wait: [30, 30, 30, 30, 30, 30]  # 30 seconds between steps\n    iterate_through_requests: true\n</code></pre>"},{"location":"quick_start/#steady-state-constant-load","title":"Steady State (constant load):","text":"<pre><code>scenarios:\n  \"steady_test\":\n    min_concurrency: 50\n    max_concurrency: 50\n    ramp_up_multiply: [50]      # Start immediately with 50 concurrent requests\n    ramp_up_wait: [0]           # No ramp-up wait\n    iterate_through_requests: true\n</code></pre>"},{"location":"quick_start/#common-commands","title":"Common Commands","text":"<pre><code># Run a test with configuration files\nstress-run --test_config config.yaml --request_config requests.yaml\n\n# Run with only test configuration (requests defined inline)\nstress-run --test_config config.yaml\n\n# Run with relative paths\nstress-run --test_config ./configs/test.yaml --request_config ./configs/requests.yaml\n</code></pre>"},{"location":"quick_start/#next-steps","title":"Next Steps","text":"<ol> <li>Read the User Guide for comprehensive usage information</li> <li>Explore the Configuration Reference for all available options</li> <li>Check out Examples for more complex test scenarios</li> <li>Learn about Development if you want to contribute</li> </ol>"},{"location":"quick_start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quick_start/#common-issues","title":"Common Issues","text":"<p>\"No module named 'gradual'\" <pre><code># Make sure you're in the project directory and have installed it\ncd gradual\npip install -e \".[dev,bokeh,websockets]\"\n</code></pre></p> <p>\"Configuration file not found\" <pre><code># Check your current directory and file paths\npwd\nls -la\n</code></pre></p> <p>\"Invalid configuration\" <pre><code># Validate your YAML syntax\npython -c \"import yaml; yaml.safe_load(open('config.yaml'))\"\n</code></pre></p> <p>\"Connection refused\" - Ensure your target application is running - Check the URL and port in your configuration - Verify firewall settings</p>"},{"location":"quick_start/#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcd6 Documentation: Check the User Guide and Configuration Reference</li> <li>\ud83d\udc1b Issues: Report bugs on GitHub Issues</li> <li>\ud83d\udcac Discussions: Ask questions on GitHub Discussions</li> </ul>"},{"location":"quick_start/#congratulations","title":"Congratulations!","text":"<p>You've successfully run your first stress test with Gradual! You now understand:</p> <ul> <li>How to configure tests using YAML files</li> <li>How to run stress tests from the command line</li> <li>How to monitor tests in real-time</li> <li>How to customize test parameters</li> </ul> <p>Continue exploring the documentation to learn about advanced features like:</p> <ul> <li>Multi-phase testing</li> <li>Authentication</li> <li>Custom protocol handlers</li> <li>Distributed testing</li> <li>Advanced reporting</li> </ul>"},{"location":"user_guide/","title":"User Guide","text":"<p>Learn how to use Gradual for stress testing your applications and systems.</p>"},{"location":"user_guide/#getting-started","title":"Getting Started","text":"<p>If you're new to Gradual, start with these guides:</p> <ul> <li>Installation Guide - Complete setup and installation instructions</li> <li>Getting Started Guide - Run your first test and learn the basics</li> </ul>"},{"location":"user_guide/#quick-reference","title":"Quick Reference","text":"<p>For experienced users, here's a quick reference of the main commands:</p> <pre><code># Run a stress test\nstress-run --test_config test_config.yaml\n\n# Run with request configuration\nstress-run --test_config test_config.yaml --request_config request_config.yaml\n\n# Start the monitoring dashboard\nstress-dashboard --mode bokeh --port 8080\n</code></pre>"},{"location":"user_guide/#configuration","title":"Configuration","text":"<p>Gradual uses a two-file configuration system that provides flexibility and clarity:</p> <ol> <li>Test Configuration (<code>test_config.yaml</code>) - Defines test structure, phases, and scenarios</li> <li>Request Configuration (<code>request_config.yaml</code>) - Defines individual HTTP and WebSocket requests</li> </ol> <p>\ud83d\udcd6 \ud83d\udca1 Need detailed configuration options? Check out the dedicated Configuration Reference tab in the navigation for a complete guide to all available settings, examples, and best practices.</p> <p>This section provides a quick overview of the configuration structure. For comprehensive configuration details, advanced examples, and troubleshooting tips, use the Configuration tab in the left navigation.</p>"},{"location":"user_guide/#test-configuration-structure","title":"Test Configuration Structure","text":"<p>The main test configuration file defines the overall test structure:</p> <pre><code>runs:\n  name: \"Test Run Name\"                    # Name of the test run\n  wait_between_phases: 10                  # Wait time between phases (seconds)\n  phases:                                  # Test phases\n    \"phase1\":                              # Phase name\n      scenarios:                           # Scenarios within this phase\n        \"scenario1\":                       # Scenario name\n          requests:                        # List of request names\n            - \"request1\"\n            - \"request2\"\n          min_concurrency: 1               # Minimum concurrent requests\n          max_concurrency: 10              # Maximum concurrent requests\n          ramp_up_multiply:                # Ramp-up multipliers (can be list or single value)\n            - 1\n            - 2\n            - 3\n          ramp_up_wait:                    # Wait time between ramp-up steps (seconds)\n            - 1\n            - 2\n            - 3\n          iterate_through_requests: true   # Whether to iterate through requests\n        \"scenario2\":                       # Another scenario\n          requests:\n            - \"request3\"\n          min_concurrency: 1\n          max_concurrency: 10\n          ramp_up_multiply: 1              # Single value (will be converted to list)\n          ramp_up_wait: 1                  # Single value (will be converted to list)\n          iterate_through_requests: true\n      run_time: 10                         # Phase duration (seconds)\n</code></pre>"},{"location":"user_guide/#request-configuration-structure","title":"Request Configuration Structure","text":"<p>The request configuration file defines individual HTTP and WebSocket requests:</p> <pre><code>requests:\n  \"request1\":                              # Request name (referenced in test config)\n    url: \"http://localhost:8000/ping\"      # Full URL\n    method: \"GET\"                          # HTTP method\n    expected_response_time: 1               # Expected response time (seconds)\n    auth: null                             # Authentication (null for none)\n  \"request2\":\n    url: \"http://localhost:8000/data\"\n    method: \"GET\"\n    expected_response_time: 1\n    auth: null\n  \"request3\":\n    url: \"http://localhost:8000/submit\"\n    method: \"POST\"\n    expected_response_time: 1\n    auth: null\n    params:                                # Request parameters/body\n      name: \"John Doe\"\n      email: \"john.doe@example.com\"\n      age: 30\n      city: \"New York\"\n      country: \"USA\"\n</code></pre>"},{"location":"user_guide/#configuration-options","title":"Configuration Options","text":""},{"location":"user_guide/#phase-configuration","title":"Phase Configuration","text":"<ul> <li><code>name</code>: Unique identifier for the phase</li> <li><code>scenarios</code>: Dictionary of scenarios to run in this phase</li> <li><code>run_time</code>: Duration of the phase in seconds</li> </ul>"},{"location":"user_guide/#scenario-configuration","title":"Scenario Configuration","text":"<ul> <li><code>requests</code>: List of request names (must match names in request config)</li> <li><code>min_concurrency</code>: Starting number of concurrent requests</li> <li><code>max_concurrency</code>: Maximum number of concurrent requests</li> <li><code>ramp_up_multiply</code>: Multipliers for gradual request increase (list or single value)</li> <li><code>ramp_up_wait</code>: Wait time between ramp-up steps in seconds (list or single value)</li> <li><code>iterate_through_requests</code>: Whether to cycle through requests sequentially</li> <li><code>run_once</code>: Whether to run the scenario only once (optional)</li> </ul>"},{"location":"user_guide/#request-configuration","title":"Request Configuration","text":"<ul> <li><code>url</code>: Full URL for the request</li> <li><code>method</code>: HTTP method (GET, POST, PUT, DELETE, etc.)</li> <li><code>expected_response_time</code>: Expected response time in seconds</li> <li><code>auth</code>: Authentication configuration (null for none)</li> <li><code>params</code>: Request parameters (for GET) or body data (for POST/PUT)</li> </ul>"},{"location":"user_guide/#ramp-up-configuration","title":"Ramp-up Configuration","text":"<p>Gradual supports two types of ramp-up strategies:</p>"},{"location":"user_guide/#multiplicative-ramp-up","title":"Multiplicative Ramp-up","text":"<pre><code>ramp_up_multiply: [1, 2, 4, 8, 16]    # Multiply requests by these factors\nramp_up_wait: [5, 5, 5, 5, 5]          # Wait 5 seconds between each step\n</code></pre> <p>This will: 1. Start with 1 concurrent request 2. Wait 5 seconds, then increase to 2 concurrent requests 3. Wait 5 seconds, then increase to 4 concurrent requests 4. Wait 5 seconds, then increase to 8 concurrent requests 5. Wait 5 seconds, then increase to 16 concurrent requests</p>"},{"location":"user_guide/#additive-ramp-up","title":"Additive Ramp-up","text":"<pre><code>ramp_up_add: [1, 2, 3, 4, 5]           # Add these numbers of requests\nramp_up_wait: [2, 2, 2, 2, 2]          # Wait 2 seconds between each step\n</code></pre> <p>This will: 1. Start with 1 concurrent request 2. Wait 2 seconds, then add 1 request (total: 2) 3. Wait 2 seconds, then add 2 requests (total: 4) 4. Wait 2 seconds, then add 3 requests (total: 7) 5. Wait 2 seconds, then add 4 requests (total: 11) 6. Wait 2 seconds, then add 5 requests (total: 16)</p>"},{"location":"user_guide/#advanced-features","title":"Advanced Features","text":""},{"location":"user_guide/#request-iteration","title":"Request Iteration","text":"<p>When <code>iterate_through_requests: true</code>, Gradual will cycle through the requests in the scenario sequentially. This is useful for simulating realistic request workflows.</p>"},{"location":"user_guide/#phase-sequencing","title":"Phase Sequencing","text":"<p>Phases run sequentially with the specified <code>wait_between_phases</code> delay. This allows you to:</p> <ul> <li>Test different load patterns</li> <li>Implement complex test scenarios</li> <li>Allow system recovery between phases</li> </ul>"},{"location":"user_guide/#dynamic-request-loading","title":"Dynamic Request Loading","text":"<p>For advanced use cases, you can reference requests from external files:</p> <pre><code>requests: \"FROM_REQUEST_YAML_FILE\"\nrequest_file: path/to/requests.yaml\n</code></pre>"},{"location":"user_guide/#best-practices","title":"Best Practices","text":""},{"location":"user_guide/#1-test-design","title":"1. Test Design","text":"<ul> <li>Start Small: Begin with low concurrency and gradually increase</li> <li>Realistic Scenarios: Model realistic request patterns</li> <li>Phase Planning: Use phases to test different load patterns</li> <li>Request Sequencing: Use <code>iterate_through_requests</code> for realistic workflows</li> </ul>"},{"location":"user_guide/#2-ramp-up-strategy","title":"2. Ramp-up Strategy","text":"<ul> <li>Gradual Increase: Use ramp-up to avoid overwhelming the system</li> <li>Monitor Performance: Watch for performance degradation during ramp-up</li> <li>Realistic Timing: Set appropriate wait times between ramp-up steps</li> </ul>"},{"location":"user_guide/#3-configuration-management","title":"3. Configuration Management","text":"<ul> <li>Separate Concerns: Keep test structure and request definitions separate</li> <li>Reusable Requests: Define requests once and reuse across scenarios</li> <li>Clear Naming: Use descriptive names for phases, scenarios, and requests</li> </ul>"},{"location":"user_guide/#example-configurations","title":"Example Configurations","text":""},{"location":"user_guide/#basic-load-test","title":"Basic Load Test","text":"<pre><code># test_config.yaml\nruns:\n  name: \"Basic Load Test\"\n  wait_between_phases: 5\n  phases:\n    \"ramp_up\":\n      scenarios:\n        \"basic_scenario\":\n          requests:\n            - \"health_check\"\n            - \"api_endpoint\"\n          min_concurrency: 1\n          max_concurrency: 50\n          ramp_up_multiply: [1, 2, 5, 10, 25, 50]\n          ramp_up_wait: [10, 10, 10, 10, 10, 10]\n          iterate_through_requests: true\n      run_time: 300\n</code></pre> <pre><code># request_config.yaml\nrequests:\n  \"health_check\":\n    url: \"http://localhost:8000/health\"\n    method: \"GET\"\n    expected_response_time: 0.5\n    auth: null\n  \"api_endpoint\":\n    url: \"http://localhost:8000/api/data\"\n    method: \"GET\"\n    expected_response_time: 1.0\n    auth: null\n</code></pre>"},{"location":"user_guide/#multi-phase-test","title":"Multi-Phase Test","text":"<pre><code># test_config.yaml\nruns:\n  name: \"Multi-Phase Test\"\n  wait_between_phases: 10\n  phases:\n    \"warm_up\":\n      scenarios:\n        \"warm_up_scenario\":\n          requests:\n            - \"light_request\"\n          min_concurrency: 1\n          max_concurrency: 10\n          ramp_up_multiply: [1, 2, 5, 10]\n          ramp_up_wait: [5, 5, 5, 5]\n          iterate_through_requests: true\n      run_time: 120\n    \"peak_load\":\n      scenarios:\n        \"peak_scenario\":\n          requests:\n            - \"heavy_request\"\n            - \"data_processing\"\n          min_concurrency: 10\n          max_concurrency: 100\n          ramp_up_multiply: [10, 25, 50, 75, 100]\n          ramp_up_wait: [10, 10, 10, 10, 10]\n          iterate_through_requests: true\n      run_time: 300\n    \"cool_down\":\n      scenarios:\n        \"cool_down_scenario\":\n          requests:\n            - \"light_request\"\n          min_concurrency: 100\n          max_concurrency: 1\n          ramp_up_add: [-20, -20, -20, -20, -19]\n          ramp_up_wait: [5, 5, 5, 5, 5]\n          iterate_through_requests: true\n      run_time: 120\n</code></pre>"},{"location":"user_guide/#custom-protocol-handlers","title":"Custom Protocol Handlers","text":"<p>Gradual supports custom protocol handlers for specialized testing scenarios. You can extend the framework to handle custom protocols beyond HTTP.</p>"},{"location":"user_guide/#creating-custom-handlers","title":"Creating Custom Handlers","text":"<pre><code>from gradual.base import BaseProtocolHandler\n\nclass CustomProtocolHandler(BaseProtocolHandler):\n    def __init__(self, config):\n        super().__init__(config)\n        # Custom initialization\n\n    def execute_request(self, request_data):\n        # Custom protocol implementation\n        # Return response data\n        return {\"status\": \"success\", \"data\": request_data}\n\n    def validate_response(self, response):\n        # Custom validation logic\n        return True\n</code></pre>"},{"location":"user_guide/#registering-custom-handlers","title":"Registering Custom Handlers","text":"<pre><code>from gradual.runners import TestRunner\n\n# Register custom handler\nrunner = TestRunner(config)\nrunner.register_protocol(\"custom\", CustomProtocolHandler)\n\n# Use in configuration\nscenario = {\n    \"protocol\": \"custom\",\n    \"config\": {...}\n}\n</code></pre>"},{"location":"user_guide/#distributed-testing","title":"Distributed Testing","text":"<p>Gradual supports distributed testing for large-scale load testing across multiple machines.</p>"},{"location":"user_guide/#distributed-architecture","title":"Distributed Architecture","text":"<pre><code># Distributed test configuration\nruns:\n  name: \"Distributed Load Test\"\n  distributed:\n    enabled: true\n    coordinator: \"192.168.1.100:6379\"  # Redis coordinator\n    workers:\n      - \"192.168.1.101:8080\"\n      - \"192.168.1.102:8080\"\n      - \"192.168.1.103:8080\"\n  phases:\n    \"distributed_phase\":\n      scenarios:\n        \"distributed_scenario\":\n          requests:\n            - \"api_request\"\n          min_concurrency: 100\n          max_concurrency: 1000\n          ramp_up_multiply: [100, 250, 500, 750, 1000]\n          ramp_up_wait: [30, 30, 30, 30, 30]\n          iterate_through_requests: true\n      run_time: 600\n</code></pre>"},{"location":"user_guide/#coordinator-setup","title":"Coordinator Setup","text":"<pre><code># Start Redis coordinator\nredis-server --port 6379\n\n# Start worker nodes\nstress-run --worker --coordinator redis://192.168.1.100:6379 --port 8080\n</code></pre>"},{"location":"user_guide/#benefits-of-distributed-testing","title":"Benefits of Distributed Testing","text":"<ul> <li>Higher Load Capacity: Distribute load across multiple machines</li> <li>Geographic Distribution: Test from different locations</li> <li>Resource Scaling: Scale horizontally without single machine limits</li> <li>Realistic Scenarios: Simulate real-world distributed traffic</li> </ul>"},{"location":"user_guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user_guide/#common-issues","title":"Common Issues","text":""},{"location":"user_guide/#configuration-errors","title":"Configuration Errors","text":"<ul> <li>Missing Fields: Ensure all required fields are present</li> <li>Invalid Values: Check that numeric values are positive</li> <li>Request References: Verify request names match between config files</li> </ul>"},{"location":"user_guide/#performance-issues","title":"Performance Issues","text":"<ul> <li>Ramp-up Too Fast: Increase wait times between ramp-up steps</li> <li>High Error Rates: Reduce concurrency or check target system health</li> <li>Memory Issues: Monitor system resources during tests</li> </ul>"},{"location":"user_guide/#running-tests","title":"Running Tests","text":"<pre><code># Run with configuration files\nstress-run --test_config my_test.yaml --request_config requests.yaml\n\n# Run with only test configuration (requests defined inline)\nstress-run --test_config my_test.yaml\n</code></pre>"},{"location":"user_guide/#next-steps","title":"Next Steps","text":"<ul> <li>New to Gradual? Start with the Installation Guide and Getting Started Guide</li> <li>Ready for more? Explore the API Reference for detailed technical information</li> <li>Looking for examples? Check out Examples for real-world use cases</li> <li>Want to contribute? Learn about Development</li> <li>Need help? Join the community discussions</li> </ul>"},{"location":"api/Http/","title":"Http","text":"<p>This page contains the API documentation for the <code>gradual.runners.request.Http</code> module.</p>"},{"location":"api/Http/#gradual.runners.request.Http","title":"<code>gradual.runners.request.Http</code>","text":"<p>The Http module provides the HttpRequest class which implements HTTP-based API requests for stress testing. It supports various HTTP methods, authentication mechanisms, and response tracking.</p>"},{"location":"api/Http/#gradual.runners.request.Http-classes","title":"Classes","text":""},{"location":"api/Http/#gradual.runners.request.Http.HttpRequest","title":"<code>HttpRequest(scenario_name: str, session: HTTPSession, run_once: bool, iterator: RequestIterator)</code>","text":"<p>               Bases: <code>_Request</code></p> <p>Implementation of HTTP-based API requests for stress testing.</p> <p>This class provides functionality for: 1. Making HTTP requests with different methods (GET, POST, PUT, DELETE) 2. Supporting Kerberos authentication 3. Tracking response times and status codes 4. Managing request sessions and connection pooling 5. Handling request completion and statistics</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>HTTPSession</code> <p>HTTP session for making requests</p> <code>_kerberos_available</code> <code>bool</code> <p>Whether Kerberos support is available</p> <code>_kerberos_auth</code> <code>HTTPKerberosAuth or None</code> <p>Cached Kerberos auth handler</p> <p>Initialize a new HTTP request instance.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_name</code> <code>str</code> <p>Name of the scenario this request belongs to</p> required <code>session</code> <code>HTTPSession</code> <p>HTTP session for making requests</p> required <code>run_once</code> <code>bool</code> <p>Whether the request should run only once</p> required <code>iterator</code> <code>RequestIterator</code> <p>Iterator for cycling through request configurations</p> required Source code in <code>src/gradual/runners/request/Http.py</code> <pre><code>def __init__(\n    self,\n    scenario_name: str,\n    session: HTTPSession,\n    run_once: bool,\n    iterator: RequestIterator,\n):\n    \"\"\"\n    Initialize a new HTTP request instance.\n\n    Args:\n        scenario_name (str): Name of the scenario this request belongs to\n        session (HTTPSession): HTTP session for making requests\n        run_once (bool): Whether the request should run only once\n        iterator (RequestIterator): Iterator for cycling through request configurations\n    \"\"\"\n    super().__init__(\n        scenario_name=scenario_name, run_once=run_once, iterator=iterator\n    )\n    self.session = session\n    self._kerberos_available = None\n    self._kerberos_auth = None\n</code></pre>"},{"location":"api/Http/#gradual.runners.request.Http.HttpRequest-attributes","title":"Attributes","text":""},{"location":"api/Http/#gradual.runners.request.Http.HttpRequest.session","title":"<code>session = session</code>  <code>instance-attribute</code>","text":""},{"location":"api/Http/#gradual.runners.request.Http.HttpRequest-functions","title":"Functions","text":""},{"location":"api/Http/#gradual.runners.request.Http.HttpRequest.requires_kerberos","title":"<code>requires_kerberos(request_type: RequestConfig) -&gt; bool</code>","text":"<p>Check if a request requires Kerberos authentication.</p> <p>Parameters:</p> Name Type Description Default <code>request_type</code> <code>RequestConfig</code> <p>The request configuration to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the request requires Kerberos authentication</p> Source code in <code>src/gradual/runners/request/Http.py</code> <pre><code>def requires_kerberos(self, request_type: RequestConfig) -&gt; bool:\n    \"\"\"\n    Check if a request requires Kerberos authentication.\n\n    Args:\n        request_type (RequestConfig): The request configuration to check\n\n    Returns:\n        bool: True if the request requires Kerberos authentication\n    \"\"\"\n    return request_type.auth == \"kerb\"\n</code></pre>"},{"location":"api/Http/#gradual.runners.request.Http.HttpRequest.get_kerberos_auth","title":"<code>get_kerberos_auth()</code>","text":"<p>Get Kerberos authentication handler if available.</p> <p>Returns:</p> Type Description <p>HTTPKerberosAuth or None: Kerberos authentication handler if available,                     None if Kerberos support is not installed.</p> Source code in <code>src/gradual/runners/request/Http.py</code> <pre><code>def get_kerberos_auth(self):\n    \"\"\"\n    Get Kerberos authentication handler if available.\n\n    Returns:\n        HTTPKerberosAuth or None: Kerberos authentication handler if available,\n                                None if Kerberos support is not installed.\n    \"\"\"\n    if not self._check_kerberos_availability():\n        return None\n    return self._kerberos_auth\n</code></pre>"},{"location":"api/Http/#gradual.runners.request.Http.HttpRequest.send_request","title":"<code>send_request(request_type: RequestConfig, req_kwargs)</code>","text":"<p>Send an HTTP request based on the request configuration.</p> <p>This method supports different HTTP methods and handles the actual request sending using the configured session.</p> <p>Parameters:</p> Name Type Description Default <code>request_type</code> <code>RequestConfig</code> <p>Configuration for this request</p> required <code>req_kwargs</code> <code>dict</code> <p>Keyword arguments for the request</p> required <p>Returns:</p> Name Type Description <code>Response</code> <p>The HTTP response from the server</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported HTTP method is specified</p> Source code in <code>src/gradual/runners/request/Http.py</code> <pre><code>def send_request(self, request_type: RequestConfig, req_kwargs):\n    \"\"\"\n    Send an HTTP request based on the request configuration.\n\n    This method supports different HTTP methods and handles the actual\n    request sending using the configured session.\n\n    Args:\n        request_type (RequestConfig): Configuration for this request\n        req_kwargs (dict): Keyword arguments for the request\n\n    Returns:\n        Response: The HTTP response from the server\n\n    Raises:\n        ValueError: If an unsupported HTTP method is specified\n    \"\"\"\n    method = request_type.http_method.lower()\n\n    if method == \"get\":\n        return self.session.get(**req_kwargs)\n\n    if method == \"post\":\n        return self.session.post(**req_kwargs)\n\n    if method == \"put\":\n        return self.session.put(**req_kwargs)\n\n    if method == \"delete\":\n        return self.session.delete(**req_kwargs)\n\n    else:\n        raise ValueError(\"Unsupported HTTP method\")\n</code></pre>"},{"location":"api/Http/#gradual.runners.request.Http.HttpRequest.on_request_completion","title":"<code>on_request_completion(request_type: RequestConfig, response: Response, response_time, start_time, end_time, params)</code>","text":"<p>Handle HTTP request completion and record statistics.</p> <p>This method is called after each HTTP request completes to: 1. Collect response data and timing information 2. Record statistics for analysis 3. Log debug information</p> <p>Parameters:</p> Name Type Description Default <code>request_type</code> <code>RequestConfig</code> <p>Configuration for this request</p> required <code>response</code> <code>Response</code> <p>The HTTP response from the server</p> required <code>response_time</code> <p>Time taken for the request in nanoseconds</p> required <code>start_time</code> <p>Start time of the request in nanoseconds</p> required <code>end_time</code> <p>End time of the request in nanoseconds</p> required <code>params</code> <code>dict</code> <p>Parameters used in the request</p> required Source code in <code>src/gradual/runners/request/Http.py</code> <pre><code>def on_request_completion(\n    self,\n    request_type: RequestConfig,\n    response: Response,\n    response_time,\n    start_time,\n    end_time,\n    params,\n):\n    \"\"\"\n    Handle HTTP request completion and record statistics.\n\n    This method is called after each HTTP request completes to:\n    1. Collect response data and timing information\n    2. Record statistics for analysis\n    3. Log debug information\n\n    Args:\n        request_type (RequestConfig): Configuration for this request\n        response (Response): The HTTP response from the server\n        response_time: Time taken for the request in nanoseconds\n        start_time: Start time of the request in nanoseconds\n        end_time: End time of the request in nanoseconds\n        params (dict): Parameters used in the request\n    \"\"\"\n    stat_data = {\n        \"request_name\": request_type.name,\n        \"url\": request_type.url,\n        \"params\": params,\n        \"context\": request_type.context,\n        \"response_time\": response_time,\n        \"status_code\": response.status_code,\n        \"start_time\": start_time,\n        \"end_time\": end_time,\n        \"iid\": params[\"iid\"],\n        \"scenario_name\": self.scenario_name,\n        \"expected_response_time\": request_type.expected_response_time,\n    }\n\n    debug(stat_data)\n    self.stats_instance.persist_stats(stat_data)\n</code></pre>"},{"location":"api/Http/#gradual.runners.request.Http.HttpRequest.run","title":"<code>run()</code>","text":"<p>Execute the HTTP request in a loop until stopped.</p> <p>This method: 1. Makes HTTP requests in a loop until stop_request is True 2. Handles request preparation and sending 3. Tracks timing and response data 4. Manages authentication and headers 5. Handles errors and exceptions 6. Closes the session when done</p> Note <p>The method will exit after a single request if run_once is True.</p> Source code in <code>src/gradual/runners/request/Http.py</code> <pre><code>def run(self):\n    \"\"\"\n    Execute the HTTP request in a loop until stopped.\n\n    This method:\n    1. Makes HTTP requests in a loop until stop_request is True\n    2. Handles request preparation and sending\n    3. Tracks timing and response data\n    4. Manages authentication and headers\n    5. Handles errors and exceptions\n    6. Closes the session when done\n\n    Note:\n        The method will exit after a single request if run_once is True.\n    \"\"\"\n    while not self.stop_request:\n        try:\n            iid = str(uuid.uuid4())\n            request_type = self.iterator.get_next_request()\n            data = request_type.params | {\"iid\": iid}\n            req_kwargs = {\n                \"headers\": {\n                    \"X-ANTICSRF-HEADER\": \"DESCO\",\n                    \"Content-type\": \"application/json\",\n                },\n                \"json\": data,\n                \"url\": request_type.url,\n            }\n\n            # Handle Kerberos authentication\n            if self.requires_kerberos(request_type):\n                auth = self.get_kerberos_auth()\n                if auth:\n                    req_kwargs[\"auth\"] = auth\n                else:\n                    raise Exception(\n                        f\"Skipping request '{request_type.name}' due to missing Kerberos authentication\"\n                    )\n\n            start_time = time_ns()\n            response = self.send_request(\n                request_type=request_type, req_kwargs=req_kwargs\n            )\n            end_time = time_ns()\n            response_time_ns = end_time - start_time\n            gevent.spawn(\n                self.on_request_completion,\n                request_type,\n                response,\n                response_time_ns,\n                start_time,\n                end_time,\n                data,\n            )\n        except Exception as e:\n            error(\n                f\"Error in request '{request_type.name if 'request_type' in locals() else 'unknown'}': {str(e)}\"\n            )\n            error(traceback.format_exc())\n\n        if self.run_once:\n            self.stop_request = True\n            break\n    self.session.close()\n</code></pre>"},{"location":"api/SocketIO/","title":"Socketio","text":"<p>This page contains the API documentation for the <code>gradual.runners.request.SocketIO</code> module.</p>"},{"location":"api/SocketIO/#gradual.runners.request.SocketIO","title":"<code>gradual.runners.request.SocketIO</code>","text":"<p>The SocketIO module provides the SocketRequest class which implements WebSocket-based API requests for stress testing. It supports WebSocket connections, message sending, and response tracking.</p>"},{"location":"api/SocketIO/#gradual.runners.request.SocketIO-classes","title":"Classes","text":""},{"location":"api/SocketIO/#gradual.runners.request.SocketIO.SocketRequest","title":"<code>SocketRequest(scenario_name: str, run_once: bool, iterator: RequestIterator)</code>","text":"<p>               Bases: <code>_Request</code></p> <p>Implementation of WebSocket-based API requests for stress testing.</p> <p>This class provides functionality for: 1. Establishing and managing WebSocket connections 2. Sending messages through WebSocket 3. Receiving and processing responses 4. Tracking connection and message timing 5. Handling connection errors and failures</p> Note <p>The class uses caching for WebSocket connections to improve performance and reduce connection overhead.</p> Source code in <code>src/gradual/runners/request/base.py</code> <pre><code>def __init__(self, scenario_name: str, run_once: bool, iterator: RequestIterator):\n    \"\"\"\n    Initialize a new request instance.\n\n    Args:\n        scenario_name (str): Name of the scenario this request belongs to\n        run_once (bool): Whether the request should run only once\n        iterator (RequestIterator): Iterator for cycling through request configurations\n    \"\"\"\n    self.stop_request = False\n    self.stats_instance = Stats.get_stats_instance()\n    self.scenario_name = scenario_name\n    self.run_once = run_once\n    self.iterator = iterator\n</code></pre>"},{"location":"api/SocketIO/#gradual.runners.request.SocketIO.SocketRequest-functions","title":"Functions","text":""},{"location":"api/SocketIO/#gradual.runners.request.SocketIO.SocketRequest.on_request_completion","title":"<code>on_request_completion(request_type: RequestConfig, response: tuple, response_time, start_time, end_time, params)</code>","text":"<p>Handle WebSocket request completion and record statistics.</p> <p>This method is called after each WebSocket interaction completes to: 1. Collect response data and timing information 2. Record statistics for analysis 3. Log debug information</p> <p>Parameters:</p> Name Type Description Default <code>request_type</code> <code>RequestConfig</code> <p>Configuration for this request</p> required <code>response</code> <code>tuple</code> <p>Tuple containing (status_code, response_message)</p> required <code>response_time</code> <p>Time taken for the interaction in nanoseconds</p> required <code>start_time</code> <p>Start time of the interaction in nanoseconds</p> required <code>end_time</code> <p>End time of the interaction in nanoseconds</p> required <code>params</code> <code>dict</code> <p>Parameters used in the message</p> required Source code in <code>src/gradual/runners/request/SocketIO.py</code> <pre><code>def on_request_completion(\n    self,\n    request_type: RequestConfig,\n    response: tuple,\n    response_time,\n    start_time,\n    end_time,\n    params,\n):\n    \"\"\"\n    Handle WebSocket request completion and record statistics.\n\n    This method is called after each WebSocket interaction completes to:\n    1. Collect response data and timing information\n    2. Record statistics for analysis\n    3. Log debug information\n\n    Args:\n        request_type (RequestConfig): Configuration for this request\n        response (tuple): Tuple containing (status_code, response_message)\n        response_time: Time taken for the interaction in nanoseconds\n        start_time: Start time of the interaction in nanoseconds\n        end_time: End time of the interaction in nanoseconds\n        params (dict): Parameters used in the message\n    \"\"\"\n    stat_data = {\n        \"request_name\": request_type.name,\n        \"url\": request_type.url,\n        \"params\": params,\n        \"context\": request_type.context,\n        \"response_time\": response_time,\n        \"status_code\": response[0],\n        \"start_time\": start_time,\n        \"end_time\": end_time,\n        \"iid\": params[\"iid\"],\n        \"scenario_name\": self.scenario_name,\n        \"expected_response_time\": request_type.expected_response_time,\n    }\n\n    debug(stat_data)\n    self.stats_instance.persist_stats(stat_data)\n</code></pre>"},{"location":"api/SocketIO/#gradual.runners.request.SocketIO.SocketRequest.create_ws_connection","title":"<code>create_ws_connection(url)</code>  <code>cached</code>","text":"<p>Create a WebSocket connection to the specified URL.</p> <p>This method is cached to reuse connections and improve performance. It handles connection errors and provides detailed error logging.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>WebSocket server URL to connect to</p> required <p>Returns:</p> Name Type Description <code>WebSocket</code> <p>Established WebSocket connection</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If connection fails, with detailed error information</p> Source code in <code>src/gradual/runners/request/SocketIO.py</code> <pre><code>@cache\ndef create_ws_connection(url):\n    \"\"\"\n    Create a WebSocket connection to the specified URL.\n\n    This method is cached to reuse connections and improve performance.\n    It handles connection errors and provides detailed error logging.\n\n    Args:\n        url (str): WebSocket server URL to connect to\n\n    Returns:\n        WebSocket: Established WebSocket connection\n\n    Raises:\n        Exception: If connection fails, with detailed error information\n    \"\"\"\n    try:\n        ws = create_connection(url)\n    except Exception as e:\n        error(f\"web socket failed to secure a connection with error: {e}\")\n        error(traceback.format_exc())\n        raise e\n    return ws\n</code></pre>"},{"location":"api/SocketIO/#gradual.runners.request.SocketIO.SocketRequest.run","title":"<code>run()</code>","text":"<p>Execute the WebSocket request in a loop until stopped.</p> <p>This method: 1. Establishes WebSocket connections 2. Sends messages in a loop until stop_request is True 3. Receives and processes responses 4. Tracks timing and response data 5. Handles connection errors and failures 6. Closes connections when done</p> Note <p>The method will exit after a single interaction if run_once is True. It handles both successful and failed message sending/receiving scenarios.</p> Source code in <code>src/gradual/runners/request/SocketIO.py</code> <pre><code>def run(self):\n    \"\"\"\n    Execute the WebSocket request in a loop until stopped.\n\n    This method:\n    1. Establishes WebSocket connections\n    2. Sends messages in a loop until stop_request is True\n    3. Receives and processes responses\n    4. Tracks timing and response data\n    5. Handles connection errors and failures\n    6. Closes connections when done\n\n    Note:\n        The method will exit after a single interaction if run_once is True.\n        It handles both successful and failed message sending/receiving scenarios.\n    \"\"\"\n    while not self.stop_request:\n        iid = str(uuid.uuid4())\n        request_type = self.handler.get_next_request()\n        ws = self.create_ws_connection(request_type.url)\n        data = request_type.params | {\"iid\": iid}\n        start_time = time_ns()\n        response_code = 200\n        response = None\n        is_sent = False\n        try:\n            ws.send(json.dumps(request_type.params))\n            is_sent = True\n        except Exception as e:\n            response_code = 503\n            error(\n                f\"Failed sending the message through websocket connection with error: {e}\"\n            )\n            error(traceback.format_exc())\n\n        try:\n            if is_sent:\n                response = ws.recv()\n        except Exception as e:\n            response_code = 500\n            error(\n                f\"Failed receiving the message through websocket connection with error: {e}\"\n            )\n            error(traceback.format_exc())\n        finally:\n            if response is not None and \"Success\" not in response:\n                error(response)\n            end_time = time_ns()\n            response_time_ns = end_time - start_time\n            gevent.spawn(\n                self.on_request_completion,\n                request_type,\n                (response_code, response),\n                response_time_ns,\n                start_time,\n                end_time,\n                data,\n            )\n            if self.run_once:\n                self.stop_request = True\n                break\n    ws.close()\n</code></pre>"},{"location":"api/adapters/","title":"Adapters","text":"<p>This page contains the API documentation for the <code>gradual.reporting.adapters</code> module.</p>"},{"location":"api/adapters/#gradual.reporting.adapters","title":"<code>gradual.reporting.adapters</code>","text":"<p>Reporting adapters for the Gradual framework.</p> <p>This module provides adapters for different output formats and destinations including logging, databases, and external monitoring systems.</p>"},{"location":"api/adapters/#gradual.reporting.adapters-modules","title":"Modules","text":""},{"location":"api/adapters/#gradual.reporting.adapters.base","title":"<code>base</code>","text":""},{"location":"api/adapters/#gradual.reporting.adapters.base-classes","title":"Classes","text":""},{"location":"api/adapters/#gradual.reporting.adapters.base.Adapter","title":"<code>Adapter(*args, **kwargs)</code>","text":"Source code in <code>src/gradual/reporting/adapters/base.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    self.stats = kwargs.get(\"stats\")\n</code></pre> Attributes <code>stats = kwargs.get('stats')</code> <code>instance-attribute</code> Functions <code>process_stats(stat_data: dict)</code> Source code in <code>src/gradual/reporting/adapters/base.py</code> <pre><code>def process_stats(self, stat_data: dict):\n    raise NotImplementedError(\"process_stats method must be implemented\")\n</code></pre>"},{"location":"api/adapters/#gradual.reporting.adapters.logging","title":"<code>logging</code>","text":""},{"location":"api/adapters/#gradual.reporting.adapters.logging-classes","title":"Classes","text":""},{"location":"api/adapters/#gradual.reporting.adapters.logging.LoggingAdapter","title":"<code>LoggingAdapter(logger: logging.Logger = size_based_logger('stress_test'), *args, **kwargs)</code>","text":"<p>               Bases: <code>Adapter</code></p> <p>Adapter that logs the stats to a file.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>The logger to use to log the stats.</p> <code>size_based_logger('stress_test')</code> <code>*args</code> <p>Additional arguments to pass to the Adapter class.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Adapter class.</p> <code>{}</code> Source code in <code>src/gradual/reporting/adapters/logging.py</code> <pre><code>def __init__(\n    self,\n    logger: logging.Logger = size_based_logger(\"stress_test\"),\n    *args,\n    **kwargs,\n):\n    self.Logger = logger\n    super().__init__(*args, **kwargs)\n</code></pre> Attributes <code>Logger = logger</code> <code>instance-attribute</code> Functions <code>process_stats(stat_data: dict)</code> Source code in <code>src/gradual/reporting/adapters/logging.py</code> <pre><code>def process_stats(self, stat_data: dict):\n    self.Logger.info(list(stat_data.items()))\n</code></pre>"},{"location":"api/adapters/#gradual.reporting.adapters.logging-functions","title":"Functions","text":""},{"location":"api/base/","title":"Base","text":"<p>This page contains the API documentation for the <code>gradual.runners.request.base</code> module.</p>"},{"location":"api/base/#gradual.runners.request.base","title":"<code>gradual.runners.request.base</code>","text":"<p>The base module provides the _Request abstract base class which defines the interface for all request implementations in the stress testing framework. This class serves as the foundation for different types of API requests (HTTP, WebSocket, etc.).</p>"},{"location":"api/base/#gradual.runners.request.base-classes","title":"Classes","text":""},{"location":"api/configs/","title":"Configs","text":"<p>This page contains the API documentation for the <code>gradual.configs</code> module.</p>"},{"location":"api/configs/#gradual.configs","title":"<code>gradual.configs</code>","text":"<p>Configuration management and validation for the Gradual framework.</p> <p>This module handles parsing, validation, and management of test configurations including scenarios, phases, and request definitions.</p>"},{"location":"api/constants/","title":"Constants","text":"<p>This page contains the API documentation for the <code>gradual.constants</code> module.</p>"},{"location":"api/constants/#gradual.constants","title":"<code>gradual.constants</code>","text":"<p>Framework constants and enumerations for the Gradual framework.</p> <p>This module defines constants used throughout the framework including request types, configuration keys, and other standardized values.</p>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>This page contains the API documentation for the <code>gradual.exceptions</code> module.</p>"},{"location":"api/exceptions/#gradual.exceptions","title":"<code>gradual.exceptions</code>","text":"<p>This module contains custom exceptions used throughout the stress testing framework. These exceptions help provide clear error messages and handle specific error cases that may occur during test configuration and execution.</p>"},{"location":"api/exceptions/#gradual.exceptions-classes","title":"Classes","text":""},{"location":"api/exceptions/#gradual.exceptions.InvalidConfigError","title":"<code>InvalidConfigError(prop=None, msg=None)</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Exception raised when user passes invalid or missing configuration properties.</p> <p>This exception is used to indicate configuration errors in the stress testing framework, such as missing required parameters or invalid values in the configuration files.</p> <p>Attributes:</p> Name Type Description <code>prop</code> <code>str</code> <p>The property for which the configuration is invalid or empty.</p> <code>msg</code> <code>str</code> <p>Detailed explanation of the error. If not provided, a default message will be generated based on the property name.</p> <p>Initialize the InvalidConfigError with property and message details.</p> <p>Parameters:</p> Name Type Description Default <code>prop</code> <code>str</code> <p>The property that caused the error</p> <code>None</code> <code>msg</code> <code>str</code> <p>Custom error message. If not provided, a default message will be generated using the property name.</p> <code>None</code> Source code in <code>src/gradual/exceptions.py</code> <pre><code>def __init__(self, prop=None, msg=None):\n    \"\"\"\n    Initialize the InvalidConfigError with property and message details.\n\n    Args:\n        prop (str, optional): The property that caused the error\n        msg (str, optional): Custom error message. If not provided, a default message\n            will be generated using the property name.\n    \"\"\"\n    if not msg and prop is None:\n        self.message = f\"Please provide a value for {prop}\"\n    else:\n        self.message = msg\n\n    super().__init__(self.message)\n</code></pre>"},{"location":"api/exceptions/#gradual.exceptions.InvalidConfigError-attributes","title":"Attributes","text":""},{"location":"api/exceptions/#gradual.exceptions.InvalidConfigError.message","title":"<code>message = f'Please provide a value for {prop}'</code>  <code>instance-attribute</code>","text":""},{"location":"api/iterators/","title":"Iterators","text":"<p>This page contains the API documentation for the <code>gradual.runners.iterators</code> module.</p>"},{"location":"api/iterators/#gradual.runners.iterators","title":"<code>gradual.runners.iterators</code>","text":"<p>The iterators module provides the RequestIterator class which manages cycling through different request configurations in a round-robin fashion. This is used to distribute load across different types of API requests during stress testing.</p>"},{"location":"api/iterators/#gradual.runners.iterators-classes","title":"Classes","text":""},{"location":"api/iterators/#gradual.runners.iterators.RequestIterator","title":"<code>RequestIterator(request_types: list[RequestConfig], request_type_index: int = 0, current: Optional[int] = None)</code>  <code>dataclass</code>","text":"<p>Iterator for cycling through different request configurations.</p> <p>This class provides a round-robin mechanism to cycle through different types of API requests during stress testing. It maintains the current position and provides methods to get the next request configuration.</p> <p>Attributes:</p> Name Type Description <code>request_types</code> <code>list[RequestConfig]</code> <p>List of request configurations to cycle through</p> <code>request_type_index</code> <code>int</code> <p>Current index in the request_types list</p> <code>current</code> <code>int</code> <p>Index of the last returned request type, None if no requests have been returned</p>"},{"location":"api/iterators/#gradual.runners.iterators.RequestIterator-attributes","title":"Attributes","text":""},{"location":"api/iterators/#gradual.runners.iterators.RequestIterator.request_types","title":"<code>request_types: list[RequestConfig]</code>  <code>instance-attribute</code>","text":""},{"location":"api/iterators/#gradual.runners.iterators.RequestIterator.request_type_index","title":"<code>request_type_index: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/iterators/#gradual.runners.iterators.RequestIterator.current","title":"<code>current: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/iterators/#gradual.runners.iterators.RequestIterator.current_request","title":"<code>current_request</code>  <code>property</code>","text":"<p>Get the current request configuration.</p> <p>Returns:</p> Name Type Description <code>RequestConfig</code> <p>The current request configuration, or None if no requests have been returned yet</p>"},{"location":"api/iterators/#gradual.runners.iterators.RequestIterator-functions","title":"Functions","text":""},{"location":"api/iterators/#gradual.runners.iterators.RequestIterator.get_next_request","title":"<code>get_next_request()</code>","text":"<p>Get the next request configuration in the round-robin sequence.</p> <p>Returns:</p> Name Type Description <code>RequestConfig</code> <p>The next request configuration to use</p> Note <p>This method cycles through the request_types list in a round-robin fashion, returning to the beginning when it reaches the end.</p> Source code in <code>src/gradual/runners/iterators.py</code> <pre><code>def get_next_request(self):\n    \"\"\"\n    Get the next request configuration in the round-robin sequence.\n\n    Returns:\n        RequestConfig: The next request configuration to use\n\n    Note:\n        This method cycles through the request_types list in a round-robin fashion,\n        returning to the beginning when it reaches the end.\n    \"\"\"\n    self.current = self.request_type_index\n    request_type = self.request_types[self.request_type_index]\n    self.request_type_index += 1\n    self.request_type_index %= len(self.request_types)\n    return request_type\n</code></pre>"},{"location":"api/logger/","title":"Logger","text":"<p>This page contains the API documentation for the <code>gradual.reporting.logger</code> module.</p>"},{"location":"api/logger/#gradual.reporting.logger","title":"<code>gradual.reporting.logger</code>","text":""},{"location":"api/logger/#gradual.reporting.logger-attributes","title":"Attributes","text":""},{"location":"api/logger/#gradual.reporting.logger.BACKUP_COUNT","title":"<code>BACKUP_COUNT = 15</code>  <code>module-attribute</code>","text":""},{"location":"api/logger/#gradual.reporting.logger.FILE_SIZE","title":"<code>FILE_SIZE = 5 * 1024 * 1024</code>  <code>module-attribute</code>","text":""},{"location":"api/logger/#gradual.reporting.logger-functions","title":"Functions","text":""},{"location":"api/logger/#gradual.reporting.logger.size_based_logger","title":"<code>size_based_logger(name: str, file_size: int = FILE_SIZE, backup_count: int = BACKUP_COUNT, log_dir: str = 'logs/stress_test')</code>","text":"<p>Create a logger that logs to a file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger.</p> required <code>file_size</code> <code>int</code> <p>The size of the log file in bytes.</p> <code>FILE_SIZE</code> <code>backup_count</code> <code>int</code> <p>The number of backup log files to keep.</p> <code>BACKUP_COUNT</code> <code>log_dir</code> <code>str</code> <p>The directory to log to.</p> <code>'logs/stress_test'</code> Source code in <code>src/gradual/reporting/logger.py</code> <pre><code>def size_based_logger(\n    name: str,\n    file_size: int = FILE_SIZE,\n    backup_count: int = BACKUP_COUNT,\n    log_dir: str = \"logs/stress_test\",\n):\n    \"\"\"\n    Create a logger that logs to a file.\n\n    Args:\n        name: The name of the logger.\n        file_size: The size of the log file in bytes.\n        backup_count: The number of backup log files to keep.\n        log_dir: The directory to log to.\n    \"\"\"\n    log_dir_path = Path(log_dir)\n    Path.mkdir(log_dir_path, exist_ok=True, parents=True)\n\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.INFO)\n\n    log_file = log_dir_path / f\"{name}.log\"\n\n    # Rotate every 5 MB, keep last 5 log files\n    handler = RotatingFileHandler(\n        log_file, maxBytes=file_size, backupCount=backup_count, encoding=\"utf-8\"\n    )\n\n    formatter = logging.Formatter(\n        \"[%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d]  %(message)s\"\n    )\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    logger.propagate = False\n    return logger\n</code></pre>"},{"location":"api/logging/","title":"Logging","text":"<p>This page contains the API documentation for the <code>gradual.reporting.adapters.logging</code> module.</p>"},{"location":"api/logging/#gradual.reporting.adapters.logging","title":"<code>gradual.reporting.adapters.logging</code>","text":""},{"location":"api/logging/#gradual.reporting.adapters.logging-classes","title":"Classes","text":""},{"location":"api/logging/#gradual.reporting.adapters.logging.LoggingAdapter","title":"<code>LoggingAdapter(logger: logging.Logger = size_based_logger('stress_test'), *args, **kwargs)</code>","text":"<p>               Bases: <code>Adapter</code></p> <p>Adapter that logs the stats to a file.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>The logger to use to log the stats.</p> <code>size_based_logger('stress_test')</code> <code>*args</code> <p>Additional arguments to pass to the Adapter class.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Adapter class.</p> <code>{}</code> Source code in <code>src/gradual/reporting/adapters/logging.py</code> <pre><code>def __init__(\n    self,\n    logger: logging.Logger = size_based_logger(\"stress_test\"),\n    *args,\n    **kwargs,\n):\n    self.Logger = logger\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"api/logging/#gradual.reporting.adapters.logging.LoggingAdapter-attributes","title":"Attributes","text":""},{"location":"api/logging/#gradual.reporting.adapters.logging.LoggingAdapter.Logger","title":"<code>Logger = logger</code>  <code>instance-attribute</code>","text":""},{"location":"api/logging/#gradual.reporting.adapters.logging.LoggingAdapter-functions","title":"Functions","text":""},{"location":"api/logging/#gradual.reporting.adapters.logging.LoggingAdapter.process_stats","title":"<code>process_stats(stat_data: dict)</code>","text":"Source code in <code>src/gradual/reporting/adapters/logging.py</code> <pre><code>def process_stats(self, stat_data: dict):\n    self.Logger.info(list(stat_data.items()))\n</code></pre>"},{"location":"api/logging/#gradual.reporting.adapters.logging-functions","title":"Functions","text":""},{"location":"api/orchestrator/","title":"Orchestrator","text":"<p>This page contains the API documentation for the <code>gradual.base.orchestrator</code> module.</p>"},{"location":"api/orchestrator/#gradual.base.orchestrator","title":"<code>gradual.base.orchestrator</code>","text":"<p>The orchestrator module provides the main coordination logic for stress testing. It manages the execution of test phases and handles the overall test flow.</p>"},{"location":"api/orchestrator/#gradual.base.orchestrator-classes","title":"Classes","text":""},{"location":"api/orchestrator/#gradual.base.orchestrator.Orchestrator","title":"<code>Orchestrator(test_config_file_path: str, request_configs_path: str)</code>","text":"<p>Main orchestrator class that coordinates the execution of stress tests.</p> <p>The Orchestrator is responsible for: 1. Loading and parsing test configurations 2. Managing the execution of test phases 3. Handling timing between test phases 4. Coordinating the overall test flow</p> <p>Attributes:</p> Name Type Description <code>test_config_file_path</code> <code>str</code> <p>Path to the main test configuration file</p> <code>request_configs_path</code> <code>str</code> <p>Path to the request configurations file</p> <code>parser</code> <code>Parser</code> <p>Instance of the configuration parser</p> <p>Initialize the Orchestrator with configuration file paths.</p> <p>Parameters:</p> Name Type Description Default <code>test_config_file_path</code> <code>str</code> <p>Path to the main test configuration file</p> required <code>request_configs_path</code> <code>str</code> <p>Path to the request configurations file</p> required Source code in <code>src/gradual/base/orchestrator.py</code> <pre><code>def __init__(self, test_config_file_path: str, request_configs_path: str):\n    \"\"\"\n    Initialize the Orchestrator with configuration file paths.\n\n    Args:\n        test_config_file_path (str): Path to the main test configuration file\n        request_configs_path (str): Path to the request configurations file\n    \"\"\"\n    self.test_config_file_path = test_config_file_path\n    self.request_configs_path = request_configs_path\n    self.parser = Parser(self.test_config_file_path, self.request_configs_path)\n    self.parser.read_configs()\n</code></pre>"},{"location":"api/orchestrator/#gradual.base.orchestrator.Orchestrator-attributes","title":"Attributes","text":""},{"location":"api/orchestrator/#gradual.base.orchestrator.Orchestrator.test_config_file_path","title":"<code>test_config_file_path = test_config_file_path</code>  <code>instance-attribute</code>","text":""},{"location":"api/orchestrator/#gradual.base.orchestrator.Orchestrator.request_configs_path","title":"<code>request_configs_path = request_configs_path</code>  <code>instance-attribute</code>","text":""},{"location":"api/orchestrator/#gradual.base.orchestrator.Orchestrator.parser","title":"<code>parser = Parser(self.test_config_file_path, self.request_configs_path)</code>  <code>instance-attribute</code>","text":""},{"location":"api/orchestrator/#gradual.base.orchestrator.Orchestrator-functions","title":"Functions","text":""},{"location":"api/orchestrator/#gradual.base.orchestrator.Orchestrator.start_stress_test","title":"<code>start_stress_test()</code>","text":"<p>Start the stress test execution.</p> <p>This method: 1. Iterates through each phase in the test configuration 2. Creates and executes a Phase instance for each configuration 3. Waits for the specified time between phases 4. Uses gevent for concurrent execution of phases</p> Source code in <code>src/gradual/base/orchestrator.py</code> <pre><code>def start_stress_test(self):\n    \"\"\"\n    Start the stress test execution.\n\n    This method:\n    1. Iterates through each phase in the test configuration\n    2. Creates and executes a Phase instance for each configuration\n    3. Waits for the specified time between phases\n    4. Uses gevent for concurrent execution of phases\n    \"\"\"\n    info(\"Starting stress test.\")\n    for idx, phase_config in enumerate(self.parser.phases):\n        phase = Phase(phase_config, self.parser.run_name)\n        running_phase = gevent.spawn(phase.execute)\n        gevent.wait([running_phase])\n\n        if idx &lt; len(self.parser.phases) - 1:\n            info(\n                f\"waiting for {self.parser.phase_wait} secs before starting new phase.\"\n            )\n            gevent.sleep(self.parser.phase_wait)\n</code></pre>"},{"location":"api/overview/","title":"API Reference","text":"<p>This page provides comprehensive API documentation for the gradual package.</p>"},{"location":"api/overview/#available-modules","title":"Available Modules","text":"<p>The following modules are automatically discovered and documented:</p> <ul> <li>Base - <code>gradual.base</code></li> <li>Configs - <code>gradual.configs</code></li> <li>Constants - <code>gradual.constants</code></li> <li>Exceptions - <code>gradual.exceptions</code></li> <li>Reporting - <code>gradual.reporting</code></li> <li>Runners - <code>gradual.runners</code></li> <li>Parser - <code>gradual.configs.parser</code></li> <li>Phase - <code>gradual.configs.phase</code></li> <li>Request - <code>gradual.configs.request</code></li> <li>Scenario - <code>gradual.configs.scenario</code></li> <li>Validate - <code>gradual.configs.validate</code></li> <li>Orchestrator - <code>gradual.base.orchestrator</code></li> <li>Request_Types - <code>gradual.constants.request_types</code></li> <li>Adapters - <code>gradual.reporting.adapters</code></li> <li>Logger - <code>gradual.reporting.logger</code></li> <li>Stats - <code>gradual.reporting.stats</code></li> <li>Base - <code>gradual.reporting.adapters.base</code></li> <li>Logging - <code>gradual.reporting.adapters.logging</code></li> <li>Iterators - <code>gradual.runners.iterators</code></li> <li>Phase - <code>gradual.runners.phase</code></li> <li>Request - <code>gradual.runners.request</code></li> <li>Runner - <code>gradual.runners.runner</code></li> <li>Scenario - <code>gradual.runners.scenario</code></li> <li>Session - <code>gradual.runners.session</code></li> <li>Http - <code>gradual.runners.request.Http</code></li> <li>Socketio - <code>gradual.runners.request.SocketIO</code></li> <li>Base - <code>gradual.runners.request.base</code></li> </ul>"},{"location":"api/overview/#automatic-discovery","title":"Automatic Discovery","text":"<p>This documentation is automatically generated using a Python script that: 1. Discovers all modules in the package 2. Generates individual documentation files for each module 3. Uses mkdocstrings to extract documentation from docstrings 4. Updates automatically when you run the script</p> <p>To regenerate all API documentation, run: <pre><code>python generate_api_docs.py\n</code></pre></p>"},{"location":"api/parser/","title":"Parser","text":"<p>This page contains the API documentation for the <code>gradual.configs.parser</code> module.</p>"},{"location":"api/parser/#gradual.configs.parser","title":"<code>gradual.configs.parser</code>","text":"<p>The parser module provides the Parser class which handles loading and parsing configuration files for stress testing. It supports YAML configuration files and validates the configuration structure.</p>"},{"location":"api/parser/#gradual.configs.parser-classes","title":"Classes","text":""},{"location":"api/parser/#gradual.configs.parser.Parser","title":"<code>Parser(test_config_file_path: str, request_configs_path: str, run_name: str | None = None, phases: list[PhaseConfig] = list(), phase_wait: int = 0)</code>  <code>dataclass</code>","text":"<p>Configuration parser for stress testing setup.</p> <p>This class handles loading and parsing of configuration files, including: 1. Test configuration files 2. Request configuration files 3. Parameter configuration files</p> <p>It validates the configuration structure and creates appropriate configuration objects for phases, scenarios, and requests.</p> <p>Attributes:</p> Name Type Description <code>test_config_file_path</code> <code>str</code> <p>Path to the main test configuration file</p> <code>request_configs_path</code> <code>str</code> <p>Path to the request configurations file</p> <code>run_name</code> <code>str | None</code> <p>Name of the test run</p> <code>phases</code> <code>list[PhaseConfig]</code> <p>List of parsed phase configurations</p> <code>phase_wait</code> <code>int</code> <p>Wait time between phases in seconds</p>"},{"location":"api/parser/#gradual.configs.parser.Parser-attributes","title":"Attributes","text":""},{"location":"api/parser/#gradual.configs.parser.Parser.test_config_file_path","title":"<code>test_config_file_path: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/parser/#gradual.configs.parser.Parser.request_configs_path","title":"<code>request_configs_path: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/parser/#gradual.configs.parser.Parser.run_name","title":"<code>run_name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/parser/#gradual.configs.parser.Parser.phases","title":"<code>phases: list[PhaseConfig] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/parser/#gradual.configs.parser.Parser.phase_wait","title":"<code>phase_wait: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/parser/#gradual.configs.parser.Parser-functions","title":"Functions","text":""},{"location":"api/parser/#gradual.configs.parser.Parser.read_request_file","title":"<code>read_request_file(file_path: Path)</code>  <code>staticmethod</code>","text":"<p>Read and parse a request configuration file.</p> <p>This method reads a YAML file containing request configurations and creates RequestConfig objects for each request definition. It validates required fields and handles optional parameters.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the request configuration file</p> required <p>Returns:</p> Type Description <p>list[RequestConfig]: List of parsed request configurations</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If required fields are missing</p> Source code in <code>src/gradual/configs/parser.py</code> <pre><code>@staticmethod\ndef read_request_file(file_path: Path):\n    \"\"\"\n    Read and parse a request configuration file.\n\n    This method reads a YAML file containing request configurations and creates\n    RequestConfig objects for each request definition. It validates required fields\n    and handles optional parameters.\n\n    Args:\n        file_path (Path): Path to the request configuration file\n\n    Returns:\n        list[RequestConfig]: List of parsed request configurations\n\n    Raises:\n        AssertionError: If required fields are missing\n    \"\"\"\n    request_config = []\n    with file_path.open(\"r\") as request_file:\n        requests = yaml.safe_load(request_file)\n        assert_not_empty(\"requests\", requests.get(\"requests\"))\n        for request_name, request in requests[\"requests\"].items():\n            assert_not_empty(\n                \"params\",\n                request.get(\"params\"),\n                f\"Please provide params for request: {request}.\",\n            )\n            assert_not_empty(\n                \"method\",\n                request.get(\"method\"),\n                f\"Please provide method for request: {request}.\",\n            )\n            assert_not_empty(\n                \"expected_response_time\",\n                request.get(\"expected_response_time\"),\n                f\"Please provide expected_response_time for request: {request}.\",\n            )\n            config = RequestConfig(\n                name=request_name,\n                url=request.get(\"url\", \"\"),\n                params=request.get(\"params\", {}),\n                http_method=request.get(\"method\", \"get\"),\n                expected_response_time=request.get(\"expected_response_time\", 0),\n                auth=request.get(\"auth\", None),\n            )\n            request_config.append(config)\n    return request_config\n</code></pre>"},{"location":"api/parser/#gradual.configs.parser.Parser.read_configs","title":"<code>read_configs()</code>","text":"<p>Read and parse all configuration files.</p> <p>This method: 1. Reads the main test configuration file 2. Reads the request configurations file if specified 3. Validates required fields and structure 4. Creates phase, scenario, and request configurations 5. Handles ramp-up and timing configurations</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If required fields are missing or invalid</p> Source code in <code>src/gradual/configs/parser.py</code> <pre><code>def read_configs(self):\n    \"\"\"\n    Read and parse all configuration files.\n\n    This method:\n    1. Reads the main test configuration file\n    2. Reads the request configurations file if specified\n    3. Validates required fields and structure\n    4. Creates phase, scenario, and request configurations\n    5. Handles ramp-up and timing configurations\n\n    Raises:\n        AssertionError: If required fields are missing or invalid\n    \"\"\"\n    info(\"Reading configs...\")\n\n    with open(self.test_config_file_path, \"r\") as scenario_file:\n        scenarios_config = yaml.safe_load(scenario_file)\n\n    if self.request_configs_path:\n        with open(self.request_configs_path, \"r\") as param_file:\n            params_config = yaml.safe_load(param_file)\n\n    else:\n        params_config = {}\n\n    self.phases = []\n\n    assert_not_empty(\"run_name\", scenarios_config[\"runs\"][\"name\"])\n    self.run_name = scenarios_config[\"runs\"][\"name\"]\n    self.phase_wait = scenarios_config[\"runs\"].get(\"wait_between_phases\", 0)\n\n    assert_not_empty(\"phases\", scenarios_config[\"runs\"].get(\"phases\"))\n\n    for phase_name, phase_data in scenarios_config[\"runs\"][\"phases\"].items():\n        scenarios = []\n\n        assert_not_empty(\n            f\"scenarios for phase: {phase_name}\",\n            phase_data.get(\"scenarios\"),\n        )\n\n        for scenario_name, scenario_data in phase_data[\"scenarios\"].items():\n            request_configs = []\n\n            if scenario_data[\"requests\"] == \"FROM_REQUEST_YAML_FILE\":\n                request_configs = self.read_request_file(\n                    scenario_data[\"request_file\"]\n                )\n            else:\n                for scenario_request_name in scenario_data[\"requests\"]:\n                    request = params_config[\"requests\"][scenario_request_name]\n                    request_configs.append(\n                        RequestConfig(\n                            name=scenario_request_name,\n                            url=request.get(\"url\", \"\"),\n                            params=request.get(\"params\", {}),\n                            http_method=request.get(\"method\", \"get\"),\n                            expected_response_time=request[\n                                \"expected_response_time\"\n                            ],\n                            auth=request.get(\"auth\", None),\n                        )\n                    )\n            ramp_up = []\n            ramp_up_wait = []\n            ramp_up_multiply = scenario_data.get(\"ramp_up_multiply\", None)\n            if ramp_up_multiply:\n                ramp_up = convert_list(ramp_up_multiply)\n                multiply = True\n            else:\n                ramp_up = convert_list(scenario_data.get(\"ramp_up_add\", 0))\n                multiply = False\n\n            ramp_up_wait = convert_list(scenario_data.get(\"ramp_up_wait\", [0.1]))\n            run_once = scenario_data.get(\"run_once\", False)\n            iterate_through_requests = scenario_data.get(\n                \"iterate_through_requests\", False\n            )\n            scenarios.append(\n                ScenarioConfig(\n                    name=scenario_name,\n                    min_concurrency=validate_min_concurrency(\n                        scenario_data[\"min_concurrency\"], multiply\n                    ),\n                    max_concurrency=scenario_data[\"max_concurrency\"],\n                    ramp_up=ramp_up,\n                    ramp_up_wait=ramp_up_wait,\n                    request_configs=request_configs,\n                    multiply=multiply,\n                    run_once=run_once,\n                    iterate_through_requests=iterate_through_requests,\n                )\n            )\n        self.phases.append(\n            PhaseConfig(\n                name=phase_name,\n                scenario_config=scenarios,\n                runtime=phase_data[\"run_time\"],\n            )\n        )\n</code></pre>"},{"location":"api/parser/#gradual.configs.parser-functions","title":"Functions","text":""},{"location":"api/parser/#gradual.configs.parser.convert_list","title":"<code>convert_list(val)</code>","text":"<p>Convert a single value to a list if it's not already a list.</p> <p>This utility function ensures that values that should be lists are always in list format, converting single values to single-item lists.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <p>Value to convert (int or list)</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The input value as a list</p> Source code in <code>src/gradual/configs/parser.py</code> <pre><code>def convert_list(val):\n    \"\"\"\n    Convert a single value to a list if it's not already a list.\n\n    This utility function ensures that values that should be lists are always\n    in list format, converting single values to single-item lists.\n\n    Args:\n        val: Value to convert (int or list)\n\n    Returns:\n        list: The input value as a list\n    Raises:\n        TypeError: If the value is not an int or list\n    \"\"\"\n    if isinstance(val, int):\n        return [val]\n    if isinstance(val, list):\n        return val\n    raise TypeError(f\"Expected int or list, got {type(val).__name__}: {val}\")\n</code></pre>"},{"location":"api/phase/","title":"Phase","text":"<p>This page contains the API documentation for the <code>gradual.runners.phase</code> module.</p>"},{"location":"api/phase/#gradual.runners.phase","title":"<code>gradual.runners.phase</code>","text":"<p>The phase module provides the Phase class which represents a single test phase in the stress testing framework. A phase is a self-contained unit of testing that can be executed independently and has its own configuration and runtime constraints.</p>"},{"location":"api/phase/#gradual.runners.phase-classes","title":"Classes","text":""},{"location":"api/phase/#gradual.runners.phase.Phase","title":"<code>Phase(phase_config: PhaseConfig, run_name: str)</code>","text":"<p>Represents a single test phase in the stress testing framework.</p> <p>A phase is a self-contained unit of testing that: 1. Has its own configuration and runtime constraints 2. Manages its own test runner and reporting 3. Can be executed independently of other phases 4. Has timeout protection to prevent indefinite execution</p> <p>Attributes:</p> Name Type Description <code>phase_config</code> <code>PhaseConfig</code> <p>Configuration for this test phase</p> <code>reporting_object</code> <code>Stats</code> <p>Statistics and reporting handler for this phase</p> <code>runner</code> <code>Runner</code> <p>Test runner instance that executes the actual tests</p> <p>Initialize a new test phase.</p> <p>Parameters:</p> Name Type Description Default <code>phase_config</code> <code>PhaseConfig</code> <p>Configuration for this test phase</p> required <code>run_name</code> <code>str</code> <p>Unique identifier for this test run</p> required Source code in <code>src/gradual/runners/phase.py</code> <pre><code>def __init__(self, phase_config: PhaseConfig, run_name: str):\n    \"\"\"\n    Initialize a new test phase.\n\n    Args:\n        phase_config (PhaseConfig): Configuration for this test phase\n        run_name (str): Unique identifier for this test run\n    \"\"\"\n    # Validation\n    if not phase_config.name:\n        raise ValueError(\"Phase name must not be empty\")\n    if phase_config.phase_runtime is not None and phase_config.phase_runtime &lt; 0:\n        raise ValueError(\"Phase runtime must be non-negative\")\n    self.phase_config = phase_config\n    self.reporting_object = Stats(self.phase_config, run_name)\n    self.runner = Runner(self.phase_config.scenario_config)\n</code></pre>"},{"location":"api/phase/#gradual.runners.phase.Phase-attributes","title":"Attributes","text":""},{"location":"api/phase/#gradual.runners.phase.Phase.phase_config","title":"<code>phase_config = phase_config</code>  <code>instance-attribute</code>","text":""},{"location":"api/phase/#gradual.runners.phase.Phase.reporting_object","title":"<code>reporting_object = Stats(self.phase_config, run_name)</code>  <code>instance-attribute</code>","text":""},{"location":"api/phase/#gradual.runners.phase.Phase.runner","title":"<code>runner = Runner(self.phase_config.scenario_config)</code>  <code>instance-attribute</code>","text":""},{"location":"api/phase/#gradual.runners.phase.Phase-functions","title":"Functions","text":""},{"location":"api/phase/#gradual.runners.phase.Phase.execute","title":"<code>execute()</code>","text":"<p>Execute the test phase.</p> <p>This method: 1. Spawns a new test runner in a gevent greenlet 2. Monitors the execution with a timeout 3. Handles timeout conditions gracefully 4. Manages the lifecycle of the test execution</p> Source code in <code>src/gradual/runners/phase.py</code> <pre><code>def execute(self):\n    \"\"\"\n    Execute the test phase.\n\n    This method:\n    1. Spawns a new test runner in a gevent greenlet\n    2. Monitors the execution with a timeout\n    3. Handles timeout conditions gracefully\n    4. Manages the lifecycle of the test execution\n    \"\"\"\n    info(\"Starting stats processing...\")\n    self.reporting_object.start_process_stats()\n\n    info(f\"Executing phase {self.phase_config.name}\")\n\n    start_test_task = gevent.spawn(self.runner.start_test)\n\n    try:\n        with gevent.Timeout(\n            self.phase_config.phase_runtime,\n            TimeoutError(\"Phase exceeded runtime.\"),\n        ):\n            gevent.wait(objects=[start_test_task])\n            info(\"Phase run complete.\")\n    except TimeoutError:\n        info(\"Runtime exceeding. stopping the phase now.\")\n        self.stop_phase()\n    except Exception:\n        self.stop_phase()\n        raise\n\n    info(\"Closing stats processing...\")\n    self.reporting_object.close_process_stats()\n</code></pre>"},{"location":"api/phase/#gradual.runners.phase.Phase.stop_phase","title":"<code>stop_phase()</code>","text":"<p>Stop the test phase execution.</p> <p>This method: 1. Logs the stopping of the phase 2. Stops the test runner 3. Confirms the phase has been stopped</p> Source code in <code>src/gradual/runners/phase.py</code> <pre><code>def stop_phase(self):\n    \"\"\"\n    Stop the test phase execution.\n\n    This method:\n    1. Logs the stopping of the phase\n    2. Stops the test runner\n    3. Confirms the phase has been stopped\n    \"\"\"\n    info(f\"Stopping Phase {self.phase_config.name}\")\n    self.runner.stop_runner()\n    info(f\"Stopped Phase {self.phase_config.name}\")\n</code></pre>"},{"location":"api/reporting/","title":"Reporting","text":"<p>This page contains the API documentation for the <code>gradual.reporting</code> module.</p>"},{"location":"api/reporting/#gradual.reporting","title":"<code>gradual.reporting</code>","text":"<p>Reporting and metrics collection for the Gradual framework.</p> <p>This module handles collection, storage, and reporting of test metrics including response times, error rates, and custom statistics.</p>"},{"location":"api/request/","title":"Request","text":"<p>This page contains the API documentation for the <code>gradual.runners.request</code> module.</p>"},{"location":"api/request/#gradual.runners.request","title":"<code>gradual.runners.request</code>","text":"<p>Request handling and execution for the Gradual framework.</p> <p>This module provides request runners for different protocols including HTTP, WebSocket, and custom protocols.</p>"},{"location":"api/request_types/","title":"Request_Types","text":"<p>This page contains the API documentation for the <code>gradual.constants.request_types</code> module.</p>"},{"location":"api/request_types/#gradual.constants.request_types","title":"<code>gradual.constants.request_types</code>","text":"<p>The request_types module provides the RequestType enum which defines the supported types of API requests in the stress testing framework. It includes HTTP and WebSocket protocols with their respective URL schemes.</p>"},{"location":"api/request_types/#gradual.constants.request_types-classes","title":"Classes","text":""},{"location":"api/request_types/#gradual.constants.request_types.RequestType","title":"<code>RequestType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported API request types and their URL schemes.</p> <p>This enum defines the different types of API requests that can be made in the stress testing framework, along with their corresponding URL protocol schemes.</p> <p>Attributes:</p> Name Type Description <code>websocket</code> <code>list[str]</code> <p>List of WebSocket URL schemes (wss, ws)</p> <code>http</code> <code>list[str]</code> <p>List of HTTP URL schemes (http, https)</p>"},{"location":"api/request_types/#gradual.constants.request_types.RequestType-attributes","title":"Attributes","text":""},{"location":"api/request_types/#gradual.constants.request_types.RequestType.websocket","title":"<code>websocket = ['wss', 'ws']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/request_types/#gradual.constants.request_types.RequestType.http","title":"<code>http = ['http', 'https']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/runner/","title":"Runner","text":"<p>This page contains the API documentation for the <code>gradual.runners.runner</code> module.</p>"},{"location":"api/runner/#gradual.runners.runner","title":"<code>gradual.runners.runner</code>","text":"<p>The runner module provides the Runner class which manages the execution of test scenarios. It coordinates multiple test scenarios running concurrently using gevent for asynchronous execution.</p>"},{"location":"api/runner/#gradual.runners.runner-classes","title":"Classes","text":""},{"location":"api/runner/#gradual.runners.runner.Runner","title":"<code>Runner(scenarios: list[ScenarioConfig])</code>","text":"<p>Manages the execution of multiple test scenarios concurrently.</p> <p>The Runner is responsible for: 1. Initializing test scenarios from configurations 2. Managing concurrent execution of scenarios using gevent 3. Tracking execution time and running state 4. Providing graceful shutdown capabilities</p> <p>Attributes:</p> Name Type Description <code>scenarios</code> <code>list[Scenario]</code> <p>List of initialized test scenarios</p> <code>start_counter</code> <code>int</code> <p>Nanosecond timestamp when the runner started</p> <code>running_scenarios</code> <code>list[Scenario]</code> <p>List of currently running scenarios</p> <code>running_scenarios_task</code> <code>list</code> <p>List of gevent tasks for running scenarios</p> <p>Initialize the test runner with scenario configurations.</p> <p>Parameters:</p> Name Type Description Default <code>scenarios</code> <code>list[ScenarioConfig]</code> <p>List of scenario configurations to run</p> required Source code in <code>src/gradual/runners/runner.py</code> <pre><code>def __init__(self, scenarios: list[ScenarioConfig]):\n    \"\"\"\n    Initialize the test runner with scenario configurations.\n\n    Args:\n        scenarios (list[ScenarioConfig]): List of scenario configurations to run\n    \"\"\"\n    self.scenarios = [Scenario(scenario_config) for scenario_config in scenarios]\n    self.start_counter = perf_counter_ns()\n    self.running_scenarios: list[Scenario] = []\n    self.running_scenarios_task: list[gevent.Greenlet] = []\n</code></pre>"},{"location":"api/runner/#gradual.runners.runner.Runner-attributes","title":"Attributes","text":""},{"location":"api/runner/#gradual.runners.runner.Runner.scenarios","title":"<code>scenarios = [(Scenario(scenario_config)) for scenario_config in scenarios]</code>  <code>instance-attribute</code>","text":""},{"location":"api/runner/#gradual.runners.runner.Runner.start_counter","title":"<code>start_counter = perf_counter_ns()</code>  <code>instance-attribute</code>","text":""},{"location":"api/runner/#gradual.runners.runner.Runner.running_scenarios","title":"<code>running_scenarios: list[Scenario] = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/runner/#gradual.runners.runner.Runner.running_scenarios_task","title":"<code>running_scenarios_task: list[gevent.Greenlet] = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/runner/#gradual.runners.runner.Runner-functions","title":"Functions","text":""},{"location":"api/runner/#gradual.runners.runner.Runner.start_test","title":"<code>start_test()</code>","text":"<p>Start the execution of all test scenarios.</p> <p>This method: 1. Spawns a gevent task for each scenario 2. Tracks running scenarios and their tasks 3. Waits for all scenarios to complete execution</p> Source code in <code>src/gradual/runners/runner.py</code> <pre><code>def start_test(self):\n    \"\"\"\n    Start the execution of all test scenarios.\n\n    This method:\n    1. Spawns a gevent task for each scenario\n    2. Tracks running scenarios and their tasks\n    3. Waits for all scenarios to complete execution\n    \"\"\"\n    info(\"Executing scenarios...\")\n\n    for scenario in self.scenarios:\n        self.running_scenarios.append(scenario)\n        self.running_scenarios_task.append(gevent.spawn(scenario.execute))\n    gevent.wait(self.running_scenarios_task)\n</code></pre>"},{"location":"api/runner/#gradual.runners.runner.Runner.stop_runner","title":"<code>stop_runner()</code>","text":"<p>Stop all running test scenarios gracefully.</p> <p>This method: 1. Signals all running scenarios to stop 2. Waits for all scenario tasks to complete 3. Ensures clean shutdown of all test activities</p> Source code in <code>src/gradual/runners/runner.py</code> <pre><code>def stop_runner(self):\n    \"\"\"\n    Stop all running test scenarios gracefully.\n\n    This method:\n    1. Signals all running scenarios to stop\n    2. Waits for all scenario tasks to complete\n    3. Ensures clean shutdown of all test activities\n    \"\"\"\n    info(\"Stopping runner.\")\n    for scenario in self.running_scenarios:\n        scenario.stop_scenario_execution = True\n    gevent.wait(self.running_scenarios_task)\n</code></pre>"},{"location":"api/runners/","title":"Runners","text":"<p>This page contains the API documentation for the <code>gradual.runners</code> module.</p>"},{"location":"api/runners/#gradual.runners","title":"<code>gradual.runners</code>","text":"<p>Test execution and load generation for the Gradual framework.</p> <p>This module handles the execution of stress tests including scenario management, request iteration, and concurrency control.</p>"},{"location":"api/scenario/","title":"Scenario","text":"<p>This page contains the API documentation for the <code>gradual.runners.scenario</code> module.</p>"},{"location":"api/scenario/#gradual.runners.scenario","title":"<code>gradual.runners.scenario</code>","text":"<p>The scenario module provides the Scenario class which manages the execution of test requests within a scenario. It handles concurrency, ramp-up, and different types of requests (HTTP, WebSocket).</p>"},{"location":"api/scenario/#gradual.runners.scenario-classes","title":"Classes","text":""},{"location":"api/scenario/#gradual.runners.scenario.Scenario","title":"<code>Scenario(scenario_config: ScenarioConfig)</code>","text":"<p>Manages the execution of test requests within a scenario.</p> <p>The Scenario class is responsible for: 1. Managing concurrent execution of test requests 2. Handling ramp-up of concurrent requests 3. Supporting different types of requests (HTTP, WebSocket) 4. Managing test sessions and iterators 5. Providing graceful shutdown capabilities</p> <p>Attributes:</p> Name Type Description <code>scenario_config</code> <code>ScenarioConfig</code> <p>Configuration for this test scenario</p> <code>running_request_tasks</code> <code>list[Greenlet]</code> <p>List of currently running request tasks</p> <code>last_request_idx</code> <code>int</code> <p>Index of the last request type used</p> <code>stop_scenario_execution</code> <code>bool</code> <p>Flag to control scenario execution</p> <code>requests</code> <code>list[_Request]</code> <p>List of request instances</p> <code>iterator</code> <code>RequestIterator</code> <p>Iterator for cycling through request types</p> <p>Initialize a new test scenario.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_config</code> <code>ScenarioConfig</code> <p>Configuration for this test scenario</p> required Source code in <code>src/gradual/runners/scenario.py</code> <pre><code>def __init__(self, scenario_config: ScenarioConfig):\n    \"\"\"\n    Initialize a new test scenario.\n\n    Args:\n        scenario_config (ScenarioConfig): Configuration for this test scenario\n    \"\"\"\n    self.scenario_config = scenario_config\n    self.running_request_tasks: list[gevent.Greenlet] = []\n    self.last_request_idx: int = 0\n    self.stop_scenario_execution = False\n    self.requests: list[_Request] = []\n    self.iterator = None\n    if self.scenario_config.iterate_through_requests:\n        self.iterator = RequestIterator(\n            request_types=self.scenario_config.request_configs\n        )\n</code></pre>"},{"location":"api/scenario/#gradual.runners.scenario.Scenario-attributes","title":"Attributes","text":""},{"location":"api/scenario/#gradual.runners.scenario.Scenario.scenario_config","title":"<code>scenario_config = scenario_config</code>  <code>instance-attribute</code>","text":""},{"location":"api/scenario/#gradual.runners.scenario.Scenario.running_request_tasks","title":"<code>running_request_tasks: list[gevent.Greenlet] = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/scenario/#gradual.runners.scenario.Scenario.last_request_idx","title":"<code>last_request_idx: int = 0</code>  <code>instance-attribute</code>","text":""},{"location":"api/scenario/#gradual.runners.scenario.Scenario.stop_scenario_execution","title":"<code>stop_scenario_execution = False</code>  <code>instance-attribute</code>","text":""},{"location":"api/scenario/#gradual.runners.scenario.Scenario.requests","title":"<code>requests: list[_Request] = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/scenario/#gradual.runners.scenario.Scenario.iterator","title":"<code>iterator = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/scenario/#gradual.runners.scenario.Scenario-functions","title":"Functions","text":""},{"location":"api/scenario/#gradual.runners.scenario.Scenario.do_ramp_up","title":"<code>do_ramp_up(ramp_up_value)</code>","text":"<p>Increase the number of concurrent requests up to the specified value.</p> <p>This method: 1. Creates new request instances based on the request type 2. Manages HTTP sessions for HTTP requests 3. Spawns new gevent tasks for each request 4. Tracks running requests and their tasks</p> <p>Parameters:</p> Name Type Description Default <code>ramp_up_value</code> <code>int</code> <p>Target number of concurrent requests to achieve</p> required Source code in <code>src/gradual/runners/scenario.py</code> <pre><code>def do_ramp_up(self, ramp_up_value):\n    \"\"\"\n    Increase the number of concurrent requests up to the specified value.\n\n    This method:\n    1. Creates new request instances based on the request type\n    2. Manages HTTP sessions for HTTP requests\n    3. Spawns new gevent tasks for each request\n    4. Tracks running requests and their tasks\n\n    Args:\n        ramp_up_value (int): Target number of concurrent requests to achieve\n    \"\"\"\n    if self.scenario_config.run_once:\n        self.running_request_tasks = []\n    session = None\n    current_concurrency = 0\n    total_request_configs = len(self.scenario_config.request_configs)\n    request_type_idx = self.last_request_idx % total_request_configs\n\n    while current_concurrency &lt; ramp_up_value:\n        current_request_type = self.scenario_config.request_configs[\n            request_type_idx\n        ]\n        if not self.scenario_config.iterate_through_requests:\n            iterator = RequestIterator(\n                request_types=[\n                    self.scenario_config.request_configs[request_type_idx]\n                ]\n            )\n        else:\n            iterator = self.iterator\n        if current_request_type.type == RequestType.http:\n            if session is None:\n                session = HTTPSession(\n                    pool_connections=ramp_up_value, pool_maxsize=ramp_up_value\n                )\n            request = HttpRequest(\n                scenario_name=self.scenario_config.name,\n                session=session,\n                run_once=self.scenario_config.run_once,\n                iterator=iterator,\n            )\n        elif current_request_type.type == RequestType.websocket:\n            request = SocketRequest(\n                scenario_name=self.scenario_config.name,\n                run_once=self.scenario_config.run_once,\n                iterator=iterator,\n            )\n        else:\n            request = _Request(\n                scenario_name=self.scenario_config.name,\n                run_once=self.scenario_config.run_once,\n                iterator=iterator,\n            )\n        self.running_request_tasks.append(gevent.spawn(request.run))\n        current_concurrency += 1\n        self.requests.append(request)\n        if len(self.running_request_tasks) &gt;= self.scenario_config.max_concurrency:\n            return\n        self.last_request_idx = request_type_idx\n\n        request_type_idx += 1\n        request_type_idx %= total_request_configs\n</code></pre>"},{"location":"api/scenario/#gradual.runners.scenario.Scenario.execute","title":"<code>execute()</code>","text":"<p>Execute the test scenario with configured ramp-up behavior.</p> <p>This method: 1. Starts with minimum concurrency 2. Gradually increases concurrency based on ramp-up configuration 3. Handles both run-once and continuous execution modes 4. Manages wait times between ramp-ups 5. Provides detailed logging of execution progress</p> Source code in <code>src/gradual/runners/scenario.py</code> <pre><code>def execute(self):\n    \"\"\"\n    Execute the test scenario with configured ramp-up behavior.\n\n    This method:\n    1. Starts with minimum concurrency\n    2. Gradually increases concurrency based on ramp-up configuration\n    3. Handles both run-once and continuous execution modes\n    4. Manages wait times between ramp-ups\n    5. Provides detailed logging of execution progress\n    \"\"\"\n    info(\n        f\"Starting the testiung with minimum concurrency i.e., {self.scenario_config.min_concurrency}, scenario: {self.scenario_config.name}\"\n    )\n\n    # Current index of ramp up and ramp up wait array.\n    ramp_up_idx = 0\n    ramp_up_wait_idx = 0\n\n    # Starting with minimum no. of requests\n    self.do_ramp_up(self.scenario_config.min_concurrency)\n    if not self.scenario_config.run_once:\n        gevent.sleep(self.scenario_config.ramp_up_wait[ramp_up_wait_idx])\n    else:\n        gevent.wait(self.running_request_tasks)\n\n    # Starting request with ramp up and ramp up wait.\n    while not self.stop_scenario_execution:\n        # Increasing ramp_up_wait_index\n        ramp_up_wait_idx += 1\n        if ramp_up_wait_idx &gt;= len(self.scenario_config.ramp_up_wait):\n            ramp_up_wait_idx = len(self.scenario_config.ramp_up_wait) - 1\n\n        # Calculating by how much we have to ramp up in this iteration.\n        if self.scenario_config.multiply:\n            # Suppose we want to ramp up the total requests by 2x and there are already x requests running in an infinite loop.\n            # Then, total requests need to be added is 2x = already_running_request(x) * (multiplication_facotr(2) -1 ) to make the concurrency 2x.\n            if not self.scenario_config.run_once:\n                ramp_up_val = len(self.running_request_tasks) * (\n                    self.scenario_config.ramp_up[ramp_up_idx] - 1\n                )\n\n            # Suppose we want to ramp up the total requests by 2x and there are already x requests with run_once True.\n            # That means we are ramping up after the requests are completed.\n            # Then, total requests needs to be added is 2x = already_running_request(x) * (multiplication_facotr(2)) to make the concurrency 2x.\n            else:\n                ramp_up_val = len(self.running_request_tasks) * (\n                    self.scenario_config.ramp_up[ramp_up_idx]\n                )\n\n        else:\n            if not self.scenario_config.run_once:\n                ramp_up_val = self.scenario_config.ramp_up[ramp_up_idx]\n            else:\n                ramp_up_val = (\n                    len(self.running_request_tasks)\n                    + self.scenario_config.ramp_up[ramp_up_idx]\n                )\n        # Ramping up by ramp_up nos.\n        if len(self.running_request_tasks) &lt; self.scenario_config.max_concurrency:\n            # Logging before ramp_up.\n            table = [\n                [\n                    len(self.running_request_tasks),\n                    self.scenario_config.name,\n                    ramp_up_val,\n                ]\n            ]\n            info(\n                tabulate(\n                    table,\n                    headers=[\n                        \"Current no. of requests\",\n                        \"Scenario Name\",\n                        \"Next ramp up value\",\n                    ],\n                )\n            )\n            self.do_ramp_up(ramp_up_value=ramp_up_val)\n\n        if self.stop_scenario_execution:\n            self.stop_scenario()\n            break\n\n        if not self.scenario_config.run_once:\n            # Waiting for ramp_up wait secs before ramping up\n            gevent.sleep(self.scenario_config.ramp_up_wait[ramp_up_wait_idx])\n        else:\n            # waitng for the running requests to finish.\n            gevent.wait(self.running_request_tasks)\n\n        # Increasing ramp_up_index\n        ramp_up_idx += 1\n        if ramp_up_idx &gt;= len(self.scenario_config.ramp_up):\n            ramp_up_idx = len(self.scenario_config.ramp_up) - 1\n\n    if self.stop_scenario_execution:\n        self.stop_scenario()\n\n    if len(self.running_request_tasks):\n        gevent.wait(self.running_request_tasks)\n</code></pre>"},{"location":"api/scenario/#gradual.runners.scenario.Scenario.stop_scenario","title":"<code>stop_scenario()</code>","text":"<p>Stop the scenario execution gracefully.</p> <p>This method: 1. Sets the stop flag for the scenario 2. Signals all running requests to stop 3. Ensures clean shutdown of all test activities</p> Source code in <code>src/gradual/runners/scenario.py</code> <pre><code>def stop_scenario(self):\n    \"\"\"\n    Stop the scenario execution gracefully.\n\n    This method:\n    1. Sets the stop flag for the scenario\n    2. Signals all running requests to stop\n    3. Ensures clean shutdown of all test activities\n    \"\"\"\n    info(f\"Stopping scenario {self.scenario_config.name}\")\n    self.stop_scenario_execution = True\n    for request in self.requests:\n        request.stop_request = True\n</code></pre>"},{"location":"api/session/","title":"Session","text":"<p>This page contains the API documentation for the <code>gradual.runners.session</code> module.</p>"},{"location":"api/session/#gradual.runners.session","title":"<code>gradual.runners.session</code>","text":"<p>The session module provides the HTTPSession class which extends the requests.Session class to provide connection pooling and reuse for HTTP requests during stress testing.</p>"},{"location":"api/session/#gradual.runners.session-classes","title":"Classes","text":""},{"location":"api/session/#gradual.runners.session.HTTPSession","title":"<code>HTTPSession(pool_connections, pool_maxsize, *args, **kwargs)</code>","text":"<p>               Bases: <code>Session</code></p> <p>Custom HTTP session class with connection pooling capabilities.</p> <p>This class extends requests.Session to provide efficient connection pooling for HTTP requests. It configures the underlying HTTPAdapter with specified pool sizes for both HTTP and HTTPS connections.</p> <p>Attributes:</p> Name Type Description <code>adapter</code> <code>HTTPAdapter</code> <p>The configured HTTP adapter with connection pooling</p> <p>Initialize the HTTP session with connection pooling configuration.</p> <p>Parameters:</p> Name Type Description Default <code>pool_connections</code> <code>int</code> <p>Number of connection pools to maintain</p> required <code>pool_maxsize</code> <code>int</code> <p>Maximum number of connections per pool</p> required <code>*args</code> <p>Additional positional arguments for Session initialization</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments for Session initialization</p> <code>{}</code> Source code in <code>src/gradual/runners/session.py</code> <pre><code>def __init__(self, pool_connections, pool_maxsize, *args, **kwargs):\n    \"\"\"\n    Initialize the HTTP session with connection pooling configuration.\n\n    Args:\n        pool_connections (int): Number of connection pools to maintain\n        pool_maxsize (int): Maximum number of connections per pool\n        *args: Additional positional arguments for Session initialization\n        **kwargs: Additional keyword arguments for Session initialization\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.adapter = HTTPAdapter(\n        pool_connections=pool_connections, pool_maxsize=pool_maxsize\n    )\n    self.mount(\"http://\", self.adapter)\n    self.mount(\"https://\", self.adapter)\n</code></pre>"},{"location":"api/session/#gradual.runners.session.HTTPSession-attributes","title":"Attributes","text":""},{"location":"api/session/#gradual.runners.session.HTTPSession.adapter","title":"<code>adapter = HTTPAdapter(pool_connections=pool_connections, pool_maxsize=pool_maxsize)</code>  <code>instance-attribute</code>","text":""},{"location":"api/session/#gradual.runners.session.HTTPSession-functions","title":"Functions","text":""},{"location":"api/session/#gradual.runners.session.HTTPSession.close","title":"<code>close()</code>","text":"<p>Close the HTTP session and its connection pools.</p> <p>This method ensures proper cleanup of all connection pools and resources associated with this session.</p> Source code in <code>src/gradual/runners/session.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the HTTP session and its connection pools.\n\n    This method ensures proper cleanup of all connection pools and resources\n    associated with this session.\n    \"\"\"\n    self.adapter.close()\n</code></pre>"},{"location":"api/stats/","title":"Stats","text":"<p>This page contains the API documentation for the <code>gradual.reporting.stats</code> module.</p>"},{"location":"api/stats/#gradual.reporting.stats","title":"<code>gradual.reporting.stats</code>","text":"<p>The stats module provides the Stats class which handles collection and processing of test statistics in the stress testing framework. It implements a singleton pattern and uses multiprocessing for efficient stats collection and processing.</p>"},{"location":"api/stats/#gradual.reporting.stats-classes","title":"Classes","text":""},{"location":"api/stats/#gradual.reporting.stats.Stats","title":"<code>Stats(phase_config: PhaseConfig, run_name: str)</code>","text":"<p>Singleton class for managing test statistics collection and processing.</p> <p>This class provides functionality for: 1. Collecting test statistics in a thread-safe manner 2. Processing statistics in a separate process 3. Managing test timing and runtime tracking 4. Supporting database persistence of statistics</p> <p>Attributes:</p> Name Type Description <code>_instance</code> <code>Stats</code> <p>Singleton instance of the Stats class</p> <code>stop_writing</code> <code>Event</code> <p>Event to signal when to stop processing stats</p> <code>stats_queue</code> <code>Queue</code> <p>Queue for passing stats between processes</p> <code>phase_config</code> <code>PhaseConfig</code> <p>Configuration for the current test phase</p> <code>test_start_time</code> <code>int</code> <p>Timestamp when the test started</p> <code>test_end_time</code> <code>int</code> <p>Timestamp when the test ended</p> <code>write_db_process</code> <code>Process</code> <p>Process for handling stats persistence</p> <code>run_name</code> <code>str</code> <p>Name of the current test run</p> <p>Initialize a new Stats instance.</p> <p>Parameters:</p> Name Type Description Default <code>phase_config</code> <code>PhaseConfig</code> <p>Configuration for the current test phase</p> required <code>run_name</code> <code>str</code> <p>Name of the current test run</p> required Source code in <code>src/gradual/reporting/stats.py</code> <pre><code>def __init__(self, phase_config: PhaseConfig, run_name: str):\n    \"\"\"\n    Initialize a new Stats instance.\n\n    Args:\n        phase_config (PhaseConfig): Configuration for the current test phase\n        run_name (str): Name of the current test run\n    \"\"\"\n    self.stats_queue: Queue = Queue()\n    self.phase_config = phase_config\n    self.test_start_time: int\n    self.test_end_time: int\n    self.write_db_process = Process(target=self.process_stats, args=())\n    self.run_name = run_name\n</code></pre>"},{"location":"api/stats/#gradual.reporting.stats.Stats-attributes","title":"Attributes","text":""},{"location":"api/stats/#gradual.reporting.stats.Stats.stop_writing","title":"<code>stop_writing = Event()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/stats/#gradual.reporting.stats.Stats.stats_queue","title":"<code>stats_queue: Queue = Queue()</code>  <code>instance-attribute</code>","text":""},{"location":"api/stats/#gradual.reporting.stats.Stats.phase_config","title":"<code>phase_config = phase_config</code>  <code>instance-attribute</code>","text":""},{"location":"api/stats/#gradual.reporting.stats.Stats.test_start_time","title":"<code>test_start_time: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/stats/#gradual.reporting.stats.Stats.test_end_time","title":"<code>test_end_time: int</code>  <code>instance-attribute</code>","text":""},{"location":"api/stats/#gradual.reporting.stats.Stats.write_db_process","title":"<code>write_db_process = Process(target=(self.process_stats), args=())</code>  <code>instance-attribute</code>","text":""},{"location":"api/stats/#gradual.reporting.stats.Stats.run_name","title":"<code>run_name = run_name</code>  <code>instance-attribute</code>","text":""},{"location":"api/stats/#gradual.reporting.stats.Stats-functions","title":"Functions","text":""},{"location":"api/stats/#gradual.reporting.stats.Stats.start_process_stats","title":"<code>start_process_stats()</code>","text":"<p>Start the process that processes the stats.</p> Source code in <code>src/gradual/reporting/stats.py</code> <pre><code>def start_process_stats(self):\n    \"\"\"\n    Start the process that processes the stats.\n    \"\"\"\n    self.write_db_process.start()\n</code></pre>"},{"location":"api/stats/#gradual.reporting.stats.Stats.close_process_stats","title":"<code>close_process_stats()</code>","text":"<p>Terminate the process that processes the stats.</p> Source code in <code>src/gradual/reporting/stats.py</code> <pre><code>def close_process_stats(self):\n    \"\"\"\n    Terminate the process that processes the stats.\n    \"\"\"\n    self.write_db_process.terminate()\n</code></pre>"},{"location":"api/stats/#gradual.reporting.stats.Stats.process_stats","title":"<code>process_stats()</code>","text":"<p>Process statistics in a separate process.</p> <p>This method runs in a separate process and: 1. Listens to the stats queue for new statistics 2. Processes received statistics using the provided adapters 3. Continues until stop_writing event is set</p> Note <p>The method uses a timeout of 1 second when waiting for new stats to allow for graceful shutdown. The timeout is used to avoid blocking the main process.</p> Source code in <code>src/gradual/reporting/stats.py</code> <pre><code>def process_stats(self):\n    \"\"\"\n    Process statistics in a separate process.\n\n    This method runs in a separate process and:\n    1. Listens to the stats queue for new statistics\n    2. Processes received statistics using the provided adapters\n    3. Continues until stop_writing event is set\n\n    Note:\n        The method uses a timeout of 1 second when waiting for new stats\n        to allow for graceful shutdown. The timeout is used to avoid\n        blocking the main process.\n    \"\"\"\n    while not self.stop_writing.is_set():\n        try:\n            stats, adapters = self.stats_queue.get(\n                timeout=1\n            )  # wait up to 1 sec for a stat to be available\n            for adapter in adapters:\n                try:\n                    adapter.process_stats(stats)\n                except Exception as e:\n                    error(\n                        f\"Stat processing failed with {adapter} with exception: {e}\"\n                    )\n                    error(traceback.format_exc())\n        except Empty:\n            # queue is empty. so do nothing\n            pass\n</code></pre>"},{"location":"api/stats/#gradual.reporting.stats.Stats.persist_stats","title":"<code>persist_stats(stats, adapters: Optional[list[Adapter]] = None)</code>","text":"<p>Add statistics to the processing queue.</p> <p>Parameters:</p> Name Type Description Default <code>stats</code> <p>Statistics to be processed and persisted</p> required <code>adapters</code> <code>Optional[list[Adapter]]</code> <p>Adapters to be used to process the stats.</p> <code>None</code> Source code in <code>src/gradual/reporting/stats.py</code> <pre><code>def persist_stats(self, stats, adapters: Optional[list[Adapter]] = None):\n    \"\"\"\n    Add statistics to the processing queue.\n\n    Args:\n        stats: Statistics to be processed and persisted\n        adapters: Adapters to be used to process the stats.\n    \"\"\"\n    if adapters is None:\n        adapters = [LoggingAdapter()]\n    self.stats_queue.put((stats, adapters))\n</code></pre>"},{"location":"api/stats/#gradual.reporting.stats.Stats.get_stats_instance","title":"<code>get_stats_instance()</code>  <code>classmethod</code>","text":"<p>Get the singleton instance of the Stats class.</p> <p>Returns:</p> Name Type Description <code>Stats</code> <p>The singleton instance</p> Source code in <code>src/gradual/reporting/stats.py</code> <pre><code>@classmethod\ndef get_stats_instance(cls):\n    \"\"\"\n    Get the singleton instance of the Stats class.\n\n    Returns:\n        Stats: The singleton instance\n    \"\"\"\n    return cls._instance\n</code></pre>"},{"location":"api/stats/#gradual.reporting.stats.Stats.current_runtime","title":"<code>current_runtime()</code>","text":"<p>Calculate the current runtime of the test.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>Time elapsed since test start in seconds</p> Source code in <code>src/gradual/reporting/stats.py</code> <pre><code>def current_runtime(self):\n    \"\"\"\n    Calculate the current runtime of the test.\n\n    Returns:\n        float: Time elapsed since test start in seconds\n    \"\"\"\n    return time.time() - self.test_start_time\n</code></pre>"},{"location":"api/validate/","title":"Validate","text":"<p>This page contains the API documentation for the <code>gradual.configs.validate</code> module.</p>"},{"location":"api/validate/#gradual.configs.validate","title":"<code>gradual.configs.validate</code>","text":"<p>The validate module provides utility functions for validating stress testing configurations. It includes functions for checking minimum concurrency values and ensuring required properties are not empty.</p>"},{"location":"api/validate/#gradual.configs.validate-classes","title":"Classes","text":""},{"location":"api/validate/#gradual.configs.validate-functions","title":"Functions","text":""},{"location":"api/validate/#gradual.configs.validate.validate_min_concurrency","title":"<code>validate_min_concurrency(min_concurrency, multiple)</code>","text":"<p>Validate and adjust minimum concurrency value based on ramp-up mode.</p> <p>This function ensures that minimum concurrency is valid when using multiplication-based ramp-up. It prevents zero concurrency scenarios that would result in no test execution.</p> <p>Parameters:</p> Name Type Description Default <code>min_concurrency</code> <code>int</code> <p>The minimum concurrency value to validate</p> required <code>multiple</code> <code>bool</code> <p>Whether multiplication-based ramp-up is being used</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The validated minimum concurrency value</p> Note <p>If multiple is True and min_concurrency is 0, the function returns 1 to prevent zero concurrency scenarios.</p> Source code in <code>src/gradual/configs/validate.py</code> <pre><code>def validate_min_concurrency(min_concurrency, multiple):\n    \"\"\"\n    Validate and adjust minimum concurrency value based on ramp-up mode.\n\n    This function ensures that minimum concurrency is valid when using\n    multiplication-based ramp-up. It prevents zero concurrency scenarios\n    that would result in no test execution.\n\n    Args:\n        min_concurrency (int): The minimum concurrency value to validate\n        multiple (bool): Whether multiplication-based ramp-up is being used\n\n    Returns:\n        int: The validated minimum concurrency value\n\n    Note:\n        If multiple is True and min_concurrency is 0, the function returns 1\n        to prevent zero concurrency scenarios.\n    \"\"\"\n    if multiple and min_concurrency == 0:\n        warning(\n            \"You have passed ramp up multiplier with minimum concurrency as 0. This will result in 0 concurrency, making minimum concurrency as 1 \"\n        )\n        return 1\n    return min_concurrency\n</code></pre>"},{"location":"api/validate/#gradual.configs.validate.assert_not_empty","title":"<code>assert_not_empty(prop, value, error_msg=None)</code>","text":"<p>Assert that a configuration property has a non-empty value.</p> <p>This function validates that required configuration properties are provided and not empty. It raises an InvalidConfigError if the validation fails.</p> <p>Parameters:</p> Name Type Description Default <code>prop</code> <code>str</code> <p>Name of the property being validated</p> required <code>value</code> <p>Value to check for emptiness</p> required <code>error_msg</code> <code>str</code> <p>Custom error message to use</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidConfigError</code> <p>If the value is empty or None</p> Source code in <code>src/gradual/configs/validate.py</code> <pre><code>def assert_not_empty(prop, value, error_msg=None):\n    \"\"\"\n    Assert that a configuration property has a non-empty value.\n\n    This function validates that required configuration properties are provided\n    and not empty. It raises an InvalidConfigError if the validation fails.\n\n    Args:\n        prop (str): Name of the property being validated\n        value: Value to check for emptiness\n        error_msg (str, optional): Custom error message to use\n\n    Raises:\n        InvalidConfigError: If the value is empty or None\n    \"\"\"\n    if not value:\n        InvalidConfigError(prop, error_msg)\n</code></pre>"}]}